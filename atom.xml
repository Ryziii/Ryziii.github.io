<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Rysi&#39;s Blog</title>
  
  <subtitle>层楼纵终究误少年，自由早晚乱余生</subtitle>
  <link href="http://ryziii.github.io/atom.xml" rel="self"/>
  
  <link href="http://ryziii.github.io/"/>
  <updated>2020-12-14T16:21:32.754Z</updated>
  <id>http://ryziii.github.io/</id>
  
  <author>
    <name>Rysi</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>interview Java底层知识：GC垃圾回收机制</title>
    <link href="http://ryziii.github.io/post/30cfdbe7.html"/>
    <id>http://ryziii.github.io/post/30cfdbe7.html</id>
    <published>2020-12-14T12:04:24.000Z</published>
    <updated>2020-12-14T16:21:32.754Z</updated>
    
    
    
    
    
    <category term="Java" scheme="http://ryziii.github.io/tags/Java/"/>
    
    <category term="interview" scheme="http://ryziii.github.io/tags/interview/"/>
    
    <category term="垃圾回收" scheme="http://ryziii.github.io/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
    
    <category term="GC" scheme="http://ryziii.github.io/tags/GC/"/>
    
  </entry>
  
  <entry>
    <title>youtube-dl与ffmpeg常用指令</title>
    <link href="http://ryziii.github.io/post/345e1706.html"/>
    <id>http://ryziii.github.io/post/345e1706.html</id>
    <published>2020-12-14T11:04:24.000Z</published>
    <updated>2020-12-14T14:39:20.421Z</updated>
    
    <content type="html"><![CDATA[<h3 id="下载视频并嵌入字幕"><a href="#下载视频并嵌入字幕" class="headerlink" title="下载视频并嵌入字幕"></a>下载视频并嵌入字幕</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">youtube-dl --write-sub --embed-sub --all-subs -f <span class="string">&#x27;bestvideo[height&lt;=1080]+bestaudio/best[height&lt;=1080]&#x27;</span> https://www.youtube.com/watch?v=C4EAenqPchE</span><br></pre></td></tr></table></figure><h3 id="ffmpeg合并mp4和m4a"><a href="#ffmpeg合并mp4和m4a" class="headerlink" title="ffmpeg合并mp4和m4a"></a>ffmpeg合并mp4和m4a</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i video.mp4 -i audio.wav \-c:v copy -c:a aac -strict experimental output.mp4</span><br></pre></td></tr></table></figure><h3 id="音频码率转换"><a href="#音频码率转换" class="headerlink" title="音频码率转换"></a>音频码率转换</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i input.mp3 -ab 128 output.mp3</span><br></pre></td></tr></table></figure><blockquote><p>128为自己设置的码率</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;下载视频并嵌入字幕&quot;&gt;&lt;a href=&quot;#下载视频并嵌入字幕&quot; class=&quot;headerlink&quot; title=&quot;下载视频并嵌入字幕&quot;&gt;&lt;/a&gt;下载视频并嵌入字幕&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td</summary>
      
    
    
    
    
    <category term="youtube-dl" scheme="http://ryziii.github.io/tags/youtube-dl/"/>
    
  </entry>
  
  <entry>
    <title>macOS系统终端默认python版本问题</title>
    <link href="http://ryziii.github.io/post/5e51fdfc.html"/>
    <id>http://ryziii.github.io/post/5e51fdfc.html</id>
    <published>2020-12-12T06:39:55.000Z</published>
    <updated>2020-12-14T10:58:57.903Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题复现"><a href="#问题复现" class="headerlink" title="问题复现"></a>问题复现</h2><p>今天用Alfred写一个py脚本用于调用tesseract做ocr文字识别，用py需要用到一个AppKit库来处理系统剪切板截图，在zsh终端pip3下载PyObjC库。在Alfred中继续调试py脚本，发现依然无法找到AppKit库，一开始以为是python版本的问题于是:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mv /usr/<span class="built_in">local</span>/bin/python3 /usr/<span class="built_in">local</span>/bin/python-bak</span><br><span class="line">ln -s /usr/<span class="built_in">local</span>/Celler/python@3.9/3.9.1/bin/python /usr/<span class="built_in">local</span>/bin</span><br></pre></td></tr></table></figure><p>做了ln将/usr/local/bin/python3替换掉，<strong>问题依旧</strong><br>以为是链接问题做了一系列的.zshrc bash_profile文件的修改，<strong>问题依旧</strong><br>最后发现Alfred调用的是系统/usr/bin/python3，于是尝试替换/usr/bin/python3，出现Read-only file system问题，发现macOS从Catalina开始就不再支持<code>mount /</code>了</p><p>于是乎最后的解决办法是在Alfred里用绝对路径调用python3处理脚本…..</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;问题复现&quot;&gt;&lt;a href=&quot;#问题复现&quot; class=&quot;headerlink&quot; title=&quot;问题复现&quot;&gt;&lt;/a&gt;问题复现&lt;/h2&gt;&lt;p&gt;今天用Alfred写一个py脚本用于调用tesseract做ocr文字识别，用py需要用到一个AppKit库来处理系统剪切板</summary>
      
    
    
    
    
    <category term="Python" scheme="http://ryziii.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>interview Java底层知识：JVM内存模型</title>
    <link href="http://ryziii.github.io/post/58916ece.html"/>
    <id>http://ryziii.github.io/post/58916ece.html</id>
    <published>2020-12-10T12:01:44.000Z</published>
    <updated>2020-12-14T13:48:27.666Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JVM内存模型架构图"><a href="#JVM内存模型架构图" class="headerlink" title="JVM内存模型架构图"></a>JVM内存模型架构图</h1><img src="https://i.imgur.com/FfHnpTj.png" width="600" ><blockquote><p>上图中Runtime Data Area就是Java内存模型</p><p><a href="https://zhuanlan.zhihu.com/p/99646724">Java内存模型参考资料</a></p></blockquote><img src="https://i.imgur.com/6Mm3zCF.png" width="600" ><h1 id="Java内存模型-线程独占"><a href="#Java内存模型-线程独占" class="headerlink" title="Java内存模型-线程独占"></a>Java内存模型-线程独占</h1><p>内存结构模型中线程独占的有：程序计数器(Program Counter Register)、Java虚拟机栈、本地方法栈</p><h2 id="程序计数器-Program-Counter-Register"><a href="#程序计数器-Program-Counter-Register" class="headerlink" title="程序计数器 (Program Counter Register)"></a>程序计数器 (Program Counter Register)</h2><ul><li>Program Counter Register是线程当前正在执行字节码指令的地址(逻辑地址)</li><li>通过改变计数器的值来选取下一条需要执行的字节码指令</li><li>每个线程拥有一个计数器，是一对一关系，即“线程私有”</li><li>对Java方法计数，如果是Native方法则计数器值为Undefined</li><li>是JVM内存模型中唯一一个不会OutOfMemory的区域</li></ul><blockquote><p>因为PCRegister只是字节码行号指示器，就是指向下一条待运行的指令的地址，永远就在内存中，所以PCRegister是JVM内存模型中唯一不规定OutOfMemory的区域</p></blockquote><h3 id="逻辑地址与物理地址"><a href="#逻辑地址与物理地址" class="headerlink" title="逻辑地址与物理地址"></a>逻辑地址与物理地址</h3><p>逻辑地址就是C语言中指针指向的地址，由段标识符和段偏移量构成，是内存管理系统产物。<br>物理地址就是内存或闪存上的真实地址。</p><blockquote><p>为什么需要逻辑地址？<br>现代操作系统需要运行多任务，需要支持运行多个进程，如果直接为进程分配内存，分配多还是分配少不好掌握。如果采用动态内存分配，则一个进程容易取不到一个完整的连续的内存空间。此时就催生出操作系统的虚拟内存系统，虚拟内存系统是对内存系统的抽象，操作系统以分页(page)的机制管理内存，每个分页4kb，虚拟内存空间中的分页(page)映射到物理内存中的一个分页(page)，操作系统只需要维护一份映射表做地址转换即可。</p></blockquote><h2 id="Java虚拟机栈-Stack"><a href="#Java虚拟机栈-Stack" class="headerlink" title="Java虚拟机栈 (Stack)"></a>Java虚拟机栈 (Stack)</h2><p>虚拟机栈是Java方法的内存模型，每个方法执行时都会产生一个栈帧，当方法运行结束，栈帧会被自动销毁不需要GC回收。每个栈帧用于存储局部变量表、操作栈、动态链接、返回地址等。<br><img src="https://i.imgur.com/cCoA8mC.png" width="600" ></p><h3 id="StackOverflowError异常"><a href="#StackOverflowError异常" class="headerlink" title="StackOverflowError异常"></a>StackOverflowError异常</h3><p>每调用一次方法都会生成一个栈帧，会将栈帧中的状态保存入栈，当递归发生次数越多时，如果超出规定最大深度就会抛出StackOverflowError.</p><h3 id="局部变量表和操作数栈"><a href="#局部变量表和操作数栈" class="headerlink" title="局部变量表和操作数栈"></a>局部变量表和操作数栈</h3><ul><li>局部变量表保存着方法运行时的所有变量</li><li>操作数栈主要用于保存程序计算过程中的中间结果，同时作为计算过程中变量的临时空间。操作数栈在方法执行过程中根据字节码指令往栈中压入或弹出数据。是后进先出方式。</li></ul><blockquote><p><a href="https://www.jianshu.com/p/0333144544e2">操作数栈参考资料</a></p></blockquote><h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p>与虚拟机栈类似，主要作用于标注了native的方法</p><h1 id="Java内存模型-共享部分"><a href="#Java内存模型-共享部分" class="headerlink" title="Java内存模型-共享部分"></a>Java内存模型-共享部分</h1><h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><p>方法区是线程共享的，主要用于存放类的信息、常量池、方法数据、方法代码等。</p><h3 id="元空间-Metaspace-和永久代-PermGen-的区别"><a href="#元空间-Metaspace-和永久代-PermGen-的区别" class="headerlink" title="元空间(Metaspace)和永久代(PermGen)的区别"></a>元空间(Metaspace)和永久代(PermGen)的区别</h3><p>Java内存模型中的方法区在Java8之前都存放在永久代中，之后存放在元空间。</p><ul><li>元空间使用的是本地内存，永久代使用的是jvm内存(永久代所在的物理内存与堆连续)</li><li>字符串常量池存在<strong>永久代</strong>中，容易出现性能问题和内存溢出。<strong>元空间</strong>不会</li><li>类和方法的信息大小难以确定，难以给<strong>永久代</strong>容量上限大小设置。<strong>元空间</strong>使用的是本地内存，理论上是本地内存上限，也可以设置上限</li><li><strong>永久代</strong>会为GC带来不必要的麻烦</li><li>使用<strong>元空间</strong>方便HotSpot与其他JVM如Jrockit的继承</li></ul><blockquote><p><a href="https://juejin.cn/post/6844904020964802574">参考资料1</a><br><a href="https://zhuanlan.zhihu.com/p/111809384">参考资料2</a></p></blockquote><h2 id="堆-Heap"><a href="#堆-Heap" class="headerlink" title="堆 (Heap)"></a>堆 (Heap)</h2><img src="https://i.imgur.com/t8ssG2L.png" width="600" ><p>Java堆是JVM中最大的一块内存，主要用于存储实例化的对象与数组。在堆中又如上图所示分了很多区域，目的是让GC能够更有效率地回收垃圾。堆的内存空间不需要时连续的。</p><h2 id="JVM三大性能调优参数"><a href="#JVM三大性能调优参数" class="headerlink" title="JVM三大性能调优参数"></a>JVM三大性能调优参数</h2><p><code>java -Xms128m -Xmx128m -Xss256k -jar xxxx.jar</code></p><ul><li>-Xss：规定了每个线程虚拟机栈的大小，一般256k足够。此配置会影响此进程中并发数的大小</li><li>-Xms：Java堆的初始值，即一个进程刚创建出来时Java堆的大小。一旦堆容量超过-Xms指定的值，则会自动扩容至-Xmx的值。</li><li>-Xmx：堆能达到的最大值。一般-Xms与-Xmx会设置为相同值。当堆不够用扩容时会发生内存抖动影响程序稳定性。</li></ul><h2 id="Java内存模型中堆和栈的区别"><a href="#Java内存模型中堆和栈的区别" class="headerlink" title="Java内存模型中堆和栈的区别"></a>Java内存模型中堆和栈的区别</h2><h3 id="解答堆栈的区别首先了解Java内存分配策略"><a href="#解答堆栈的区别首先了解Java内存分配策略" class="headerlink" title="解答堆栈的区别首先了解Java内存分配策略"></a>解答堆栈的区别首先了解Java内存分配策略</h3><ul><li>静态存储：编译时确定每个数据目标在运行时的存储空间需求；</li><li>栈式存储：内存需求在编译时未知，但运行此模块前在模块入口处必须确定模块内存空间需求，遵循先进后出原则分配内存；</li><li>堆式存储：在编译时或运行模块时都无法确定内存需求，比如可变长度串、对象实例等，动态分配内存</li></ul><h3 id="堆和栈的联系"><a href="#堆和栈的联系" class="headerlink" title="堆和栈的联系"></a>堆和栈的联系</h3><p>对象、数组占据的空间被分配在堆中，但在引用数组或对象时会在栈中定义一个变量保存此数组或对象目标在堆中所处目标的首地址。如下图：</p><img src="https://i.imgur.com/o3mSU5A.png" width="600" ><h3 id="堆与栈的区别"><a href="#堆与栈的区别" class="headerlink" title="堆与栈的区别"></a>堆与栈的区别</h3><ol><li>内存管理方式：栈内存空间由JVM管理，是编译器可操作内容，堆空间由GC管理回收；</li><li>空间大小：<strong>一般栈所占空间比堆小</strong>，因为栈中存储的数据特性决定其所需空间小，因为一般Java程序需要较多对象数据，而对象一般存储在堆中所以堆空间一般比较大；</li><li>碎片相关：<strong>栈产生的内存碎片远小于堆</strong>，因为栈内存没有堆复杂，一般是栈帧出入栈操作，而堆空间相对复杂，操作也较多，所以较为容易累积内存碎片；</li><li>内存分配方式：栈支持静态和动态分配，堆只支持动态分配；</li><li>效率：<strong>栈的效率比堆高</strong>，因为计算机底层本身就是用栈管理内存，栈的操作只有出入栈比堆简单的多，但在灵活性与动态管理方面不如堆，堆的实现采用的数据结构是双向链表，比栈复杂的多。</li></ol><h3 id="元空间-Metaspace-、堆-Heap-、线程私有部分之间的联系"><a href="#元空间-Metaspace-、堆-Heap-、线程私有部分之间的联系" class="headerlink" title="元空间(Metaspace)、堆(Heap)、线程私有部分之间的联系"></a>元空间(Metaspace)、堆(Heap)、线程私有部分之间的联系</h3><img src="https://i.imgur.com/vkvxseT.jpg" width="600" ><img src="https://i.imgur.com/dKR4ppt.png" width="600" ><h3 id="不同JDK版本之间intern"><a href="#不同JDK版本之间intern" class="headerlink" title="不同JDK版本之间intern()"></a>不同JDK版本之间intern()</h3><img src="https://i.imgur.com/POe6lQA.jpg" width="600" >]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;JVM内存模型架构图&quot;&gt;&lt;a href=&quot;#JVM内存模型架构图&quot; class=&quot;headerlink&quot; title=&quot;JVM内存模型架构图&quot;&gt;&lt;/a&gt;JVM内存模型架构图&lt;/h1&gt;&lt;img src=&quot;https://i.imgur.com/FfHnpTj.png</summary>
      
    
    
    
    
    <category term="Java" scheme="http://ryziii.github.io/tags/Java/"/>
    
    <category term="interview" scheme="http://ryziii.github.io/tags/interview/"/>
    
    <category term="JVM" scheme="http://ryziii.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Sublime 快捷键</title>
    <link href="http://ryziii.github.io/post/d9ed0149.html"/>
    <id>http://ryziii.github.io/post/d9ed0149.html</id>
    <published>2020-12-10T04:48:28.000Z</published>
    <updated>2020-12-14T13:46:56.105Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Sublime-Text-3-快捷键"><a href="#Sublime-Text-3-快捷键" class="headerlink" title="Sublime Text 3 快捷键"></a>Sublime Text 3 快捷键</h1><p>Ctrl+Shift+P：打开命令面板</p><p>Ctrl+P：搜索项目中的文件</p><p>Ctrl+G：跳转到第几行</p><p>Ctrl+W：关闭当前打开文件</p><p>Ctrl+Shift+W：关闭所有打开文件</p><p>Ctrl+Shift+V：粘贴并格式化</p><p>Ctrl+D：选择单词，重复可增加选择下一个相同的单词</p><p>Ctrl+L：选择行，重复可依次增加选择下一行</p><p>Ctrl+Shift+L：选择多行</p><p>Ctrl+Shift+Enter：在当前行前插入新行</p><p>Ctrl+X：删除当前行</p><p>Ctrl+M：跳转到对应括号</p><p>Ctrl+U：软撤销，撤销光标位置</p><p>Ctrl+J：选择标签内容</p><p>Ctrl+F：查找内容</p><p>Ctrl+Shift+F：查找并替换</p><p>Ctrl+H：替换</p><p>Ctrl+R：前往 method</p><p>Ctrl+N：新建窗口</p><p>Ctrl+K+B：开关侧栏</p><p>Ctrl+Shift+M：选中当前括号内容，重复可选着括号本身</p><p>Ctrl+F2：设置/删除标记</p><p>Ctrl+/：注释当前行</p><p>Ctrl+Shift+/：当前位置插入注释</p><p>Ctrl+Alt+/：块注释，并Focus到首行，写注释说明用的</p><p>Ctrl+Shift+A：选择当前标签前后，修改标签用的</p><p>F11：全屏</p><p>Shift+F11：全屏免打扰模式，只编辑当前文件</p><p>Alt+F3：选择所有相同的词</p><p>Alt+.：闭合标签</p><p>Alt+Shift+数字：分屏显示</p><p>Alt+数字：切换打开第N个文件</p><p>Shift+右键拖动：光标多不，用来更改或插入列内容</p><p>鼠标的前进后退键可切换Tab文件</p><p>按Ctrl，依次点击或选取，可需要编辑的多个位置</p><p>按Ctrl+Shift+上下键，可替换行</p><p>##选择类<br>Ctrl+D 选中光标所占的文本，继续操作则会选中下一个相同的文本。</p><p>Alt+F3 选中文本按下快捷键，即可一次性选择全部的相同文本进行同时编辑。举个栗子：快速选中并更改所有相同的变量名、函数名等。</p><p>Ctrl+L 选中整行，继续操作则继续选择下一行，效果和 Shift+↓ 效果一样。</p><p>Ctrl+Shift+L 先选中多行，再按下快捷键，会在每行行尾插入光标，即可同时编辑这些行。</p><p>Ctrl+Shift+M 选择括号内的内容（继续选择父括号）。举个栗子：快速选中删除函数中的代码，重写函数体代码或重写括号内里的内容。</p><p>Ctrl+M 光标移动至括号内结束或开始的位置。</p><p>Ctrl+Enter 在下一行插入新行。举个栗子：即使光标不在行尾，也能快速向下插入一行。</p><p>Ctrl+Shift+Enter 在上一行插入新行。举个栗子：即使光标不在行首，也能快速向上插入一行。</p><p>Ctrl+Shift+[ 选中代码，按下快捷键，折叠代码。</p><p>Ctrl+Shift+] 选中代码，按下快捷键，展开代码。</p><p>Ctrl+K+0 展开所有折叠代码。</p><p>Ctrl+← 向左单位性地移动光标，快速移动光标。</p><p>Ctrl+→ 向右单位性地移动光标，快速移动光标。</p><p>shift+↑ 向上选中多行。</p><p>shift+↓ 向下选中多行。</p><p>Shift+← 向左选中文本。</p><p>Shift+→ 向右选中文本。</p><p>Ctrl+Shift+← 向左单位性地选中文本。</p><p>Ctrl+Shift+→ 向右单位性地选中文本。</p><p>Ctrl+Shift+↑ 将光标所在行和上一行代码互换（将光标所在行插入到上一行之前）。</p><p>Ctrl+Shift+↓ 将光标所在行和下一行代码互换（将光标所在行插入到下一行之后）。</p><p>Ctrl+Alt+↑ 向上添加多行光标，可同时编辑多行。</p><p>Ctrl+Alt+↓ 向下添加多行光标，可同时编辑多行。</p><h2 id="编辑类"><a href="#编辑类" class="headerlink" title="编辑类"></a>编辑类</h2><p>Ctrl+J 合并选中的多行代码为一行。举个栗子：将多行格式的CSS属性合并为一行。</p><p>Ctrl+Shift+D 复制光标所在整行，插入到下一行。</p><p>Tab 向右缩进。</p><p>Shift+Tab 向左缩进。</p><p>Ctrl+K+K 从光标处开始删除代码至行尾。</p><p>Ctrl+Shift+K 删除整行。</p><p>Ctrl+/ 注释单行。</p><p>Ctrl+Shift+/ 注释多行。</p><p>Ctrl+K+U 转换大写。</p><p>Ctrl+K+L 转换小写。</p><p>Ctrl+Z 撤销。</p><p>Ctrl+Y 恢复撤销。</p><p>Ctrl+U 软撤销，感觉和 Gtrl+Z 一样。</p><p>Ctrl+F2 设置书签</p><p>Ctrl+T 左右字母互换。</p><p>F6 单词检测拼写</p><h2 id="搜索类"><a href="#搜索类" class="headerlink" title="搜索类"></a>搜索类</h2><p>Ctrl+F 打开底部搜索框，查找关键字。</p><p>Ctrl+shift+F 在文件夹内查找，与普通编辑器不同的地方是sublime允许添加多个文件夹进行查找，略高端，未研究。</p><p>Ctrl+P 打开搜索框。举个栗子：1、输入当前项目中的文件名，快速搜索文件，2、输入@和关键字，查找文件中函数名，3、输入：和数字，跳转到文件中该行代码，4、输入#和关键字，查找变量名。</p><p>Ctrl+G 打开搜索框，自动带：，输入数字跳转到该行代码。举个栗子：在页面代码比较长的文件中快速定位。</p><p>Ctrl+R 打开搜索框，自动带@，输入关键字，查找文件中的函数名。举个栗子：在函数较多的页面快速查找某个函数。</p><p>Ctrl+： 打开搜索框，自动带#，输入关键字，查找文件中的变量名、属性名等。</p><p>Ctrl+Shift+P 打开命令框。场景栗子：打开命名框，输入关键字，调用sublime text或插件的功能，例如使用package安装插件。</p><p>Esc 退出光标多行选择，退出搜索框，命令框等。</p><h2 id="显示类"><a href="#显示类" class="headerlink" title="显示类"></a>显示类</h2><p>Ctrl+Tab 按文件浏览过的顺序，切换当前窗口的标签页。</p><p>Ctrl+PageDown 向左切换当前窗口的标签页。</p><p>Ctrl+PageUp 向右切换当前窗口的标签页。</p><p>Alt+Shift+1 窗口分屏，恢复默认1屏（非小键盘的数字）</p><p>Alt+Shift+2 左右分屏-2列</p><p>Alt+Shift+3 左右分屏-3列</p><p>Alt+Shift+4 左右分屏-4列</p><p>Alt+Shift+5 等分4屏</p><p>Alt+Shift+8 垂直分屏-2屏</p><p>Alt+Shift+9 垂直分屏-3屏</p><p>Ctrl+K+B 开启/关闭侧边栏。</p><p>F11 全屏模式</p><p>Shift+F11 免打扰模式</p><p>Ctrl+k+2 折叠注释和方法</p><p>Ctrl+k+3 折叠if</p><p>Ctrl+k+4 折叠switch</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Sublime-Text-3-快捷键&quot;&gt;&lt;a href=&quot;#Sublime-Text-3-快捷键&quot; class=&quot;headerlink&quot; title=&quot;Sublime Text 3 快捷键&quot;&gt;&lt;/a&gt;Sublime Text 3 快捷键&lt;/h1&gt;&lt;p&gt;Ctrl+S</summary>
      
    
    
    
    
    <category term="Sublime" scheme="http://ryziii.github.io/tags/Sublime/"/>
    
  </entry>
  
  <entry>
    <title>brew 常用指令</title>
    <link href="http://ryziii.github.io/post/eef7a1b5.html"/>
    <id>http://ryziii.github.io/post/eef7a1b5.html</id>
    <published>2020-12-09T15:01:05.000Z</published>
    <updated>2020-12-14T13:47:52.495Z</updated>
    
    <content type="html"><![CDATA[<h1 id="如何更新"><a href="#如何更新" class="headerlink" title="如何更新"></a>如何更新</h1><p>更新 Homebrew 自己：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew update</span><br></pre></td></tr></table></figure><p>查看哪些安装包需要更新：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew outdated</span><br></pre></td></tr></table></figure><p>更新：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">brew upgrade             <span class="comment"># 更新所有的包</span></span><br><span class="line">brew upgrade <span class="variable">$FORMULA</span>    <span class="comment"># 更新指定的包</span></span><br></pre></td></tr></table></figure><p>清理旧版本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">brew cleanup             <span class="comment"># 清理所有包的旧版本</span></span><br><span class="line">brew cleanup <span class="variable">$FORMULA</span>    <span class="comment"># 清理指定包的旧版本</span></span><br><span class="line">brew cleanup -n          <span class="comment"># 查看可清理的旧版本包，不执行实际操作</span></span><br></pre></td></tr></table></figure><p>锁定不想更新的包：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">brew pin <span class="variable">$FORMULA</span>      <span class="comment"># 锁定某个包</span></span><br><span class="line">brew unpin <span class="variable">$FORMULA</span>    <span class="comment"># 取消锁定</span></span><br></pre></td></tr></table></figure><p>查看安装包的相关信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">brew info <span class="variable">$FORMULA</span>    <span class="comment"># 显示某个包的信息</span></span><br><span class="line">brew info             <span class="comment"># 显示安装了包数量，文件数量，和总占用空间</span></span><br><span class="line">brew deps --installed --tree <span class="comment"># 查看已安装的包的依赖，树形显示</span></span><br></pre></td></tr></table></figure><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>列出已安装包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew list</span><br></pre></td></tr></table></figure><p>删除</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">brew rm <span class="variable">$FORMULA</span>                <span class="comment"># 删除某个包</span></span><br><span class="line">brew uninstall <span class="variable">$FORMULA</span>         <span class="comment"># 卸载某个包</span></span><br><span class="line">brew uninstall --force <span class="variable">$FORMULA</span> <span class="comment"># 删除所有版本</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;如何更新&quot;&gt;&lt;a href=&quot;#如何更新&quot; class=&quot;headerlink&quot; title=&quot;如何更新&quot;&gt;&lt;/a&gt;如何更新&lt;/h1&gt;&lt;p&gt;更新 Homebrew 自己：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;</summary>
      
    
    
    
    
    <category term="brew" scheme="http://ryziii.github.io/tags/brew/"/>
    
  </entry>
  
  <entry>
    <title>interview JVM： 反射、loadClass</title>
    <link href="http://ryziii.github.io/post/faaa6b07.html"/>
    <id>http://ryziii.github.io/post/faaa6b07.html</id>
    <published>2020-12-08T07:47:34.000Z</published>
    <updated>2020-12-14T10:54:25.754Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引子————谈到Java你会想到什么"><a href="#引子————谈到Java你会想到什么" class="headerlink" title="引子————谈到Java你会想到什么"></a>引子————谈到Java你会想到什么</h1><ol><li>平台无关性，一次编译处处运行；</li><li>GC(Garbage Collection)垃圾回收机制；</li><li>语言特性：范型、反射、Lambda表达式；</li><li>面向对象：封装、继承、多态；</li><li>类库：集合类、并发类、网络类、IO类；</li><li>异常处理；</li></ol><h2 id="Java的平台无关性"><a href="#Java的平台无关性" class="headerlink" title="Java的平台无关性"></a>Java的平台无关性</h2><p>Java源代码被编译为字节码，由不同平台的JVM进行解析，Java源代码在不同平台上不需要重新编译，JVM在执行字节码时会自动将其转化为能在该平台上运行的机器指令。</p><h3 id="字节码：-为什么JVM要先将源码文件编译为字节码不直接将源码文件解析成机器码去执行"><a href="#字节码：-为什么JVM要先将源码文件编译为字节码不直接将源码文件解析成机器码去执行" class="headerlink" title="字节码： 为什么JVM要先将源码文件编译为字节码不直接将源码文件解析成机器码去执行"></a>字节码： 为什么JVM要先将源码文件编译为字节码不直接将源码文件解析成机器码去执行</h3><ol><li>字节码是中间文件，从源代码到字节码过程中有许多校验检查工作，如果直接由JVM执行Java代码将在这一步浪费很多时间。</li><li>其他语言也可以转化成字节码由JVM执行。</li></ol><h3 id="类从编译到执行的过程"><a href="#类从编译到执行的过程" class="headerlink" title="类从编译到执行的过程"></a>类从编译到执行的过程</h3><ol><li>编译器将test.java源代码编译为test.class字节码文件</li><li>ClassLoader将字节码转换为JVM中的Class<test>对象</li><li>JVM利用Class<test>对象是梨花test对象</li></ol><h2 id="JVM如何加载-class文件"><a href="#JVM如何加载-class文件" class="headerlink" title="JVM如何加载.class文件"></a>JVM如何加载.class文件</h2><p><img src="https://i.imgur.com/FfHnpTj.png" alt="FfHnpTj"></p><h2 id="ClassLoader"><a href="#ClassLoader" class="headerlink" title="ClassLoader"></a>ClassLoader</h2><p><img src="https://i.imgur.com/iWCGLjO.png" alt="iWCGLjO"></p><h3 id="ClassLoader种类"><a href="#ClassLoader种类" class="headerlink" title="ClassLoader种类"></a>ClassLoader种类</h3><ul><li>BootStrapClassLoader：C++编写，加载核心库java.*</li><li>ExtClassLoader：Java编写，加载拓展库javax.*</li><li>AppClassLoader：Java编写，加载程序所在目录</li><li>自定义ClassLoader：Java编写，定制化加载</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ClassLoader cl = ClassLoader.getSystemClassLoader();</span><br><span class="line">Class wali = cl.loadClass(<span class="string">&quot;com.test.javabasic.reflect.Wali&quot;</span>);</span><br><span class="line">System.out.println(wali.getClassLoader());</span><br><span class="line">wali.getDeclaredConstructor().newInstance();</span><br><span class="line"></span><br><span class="line">---------------</span><br><span class="line">输出结果：</span><br><span class="line">jdk.internal.loader.ClassLoaders$AppClassLoader@2c13da15</span><br><span class="line">hello wali</span><br></pre></td></tr></table></figure><p>Wali.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test.javabasic.reflect;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Wali</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello wali&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="loadClass-与forName"><a href="#loadClass-与forName" class="headerlink" title="loadClass()与forName()"></a>loadClass()与forName()</h3><p>Class.forName会初始化类所以能动态执行静态代码块，ClassLoader.loadClass不可以，Class.forName还可以获取原生类型的Class。<br>Class.forName例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 因为mysql.jdbc.Driver类中有static代码段</span></span><br><span class="line">Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br></pre></td></tr></table></figure><p>ClassLoader.loadClass例子：<br>JVM和SpringAOC中大量用到，用于延迟加载，就是按需加载，这可以提高性能加快加载速度，在实际用到类再去加载。</p><blockquote><p><a href="https://zhuanlan.zhihu.com/p/51374915">详细的参考文章</a></p></blockquote><h2 id="ClassLoader的双亲委派机制"><a href="#ClassLoader的双亲委派机制" class="headerlink" title="ClassLoader的双亲委派机制"></a>ClassLoader的双亲委派机制</h2><p><img src="https://i.imgur.com/5CXXm9a.jpg" alt="5CXXm9a"></p><p>双亲委派制度是ClassLoader需要调用loadClass()加载某个类时，在此ClassLoader找不到时，就向上把任务交给其父类加载器，一层层向上寻找是否加载过此类，如果最上层的BootstrapClassLoader也未加载过此类时，则去rt.jar或其他jar包寻找，找不到就下放到PlatformClassLoader寻找/ext/*.jar或制定的jar包，找不到就下放到ApplicationClassLoader指定的目录中去寻找类和jar包，找不到就使用自定义的ClassLoader类重写的findClass寻找class，还找不到就返回null。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">ClassLoder简化源码：</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 很清晰的看出来内部的『双亲委派』模型</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">            <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">            Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        c = findBootstrapClassOrNull(name);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                    <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                    <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                    <span class="comment">// to find the class.</span></span><br><span class="line">                    <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">                    c = findClass(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">                resolveClass(c);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 空实现，需要我们自己来实现其加载逻辑</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将字节流转化为Class对象</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> Class&lt;?&gt; defineClass(String name, <span class="keyword">byte</span>[] b, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span><br><span class="line">            <span class="keyword">throws</span> ClassFormatError</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> defineClass(name, b, off, len, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>详情参考：<a href="https://www.codeleading.com/article/81604283329/">https://www.codeleading.com/article/81604283329/</a></p></blockquote><h3 id="为什么需要使用双亲委托机制"><a href="#为什么需要使用双亲委托机制" class="headerlink" title="为什么需要使用双亲委托机制"></a>为什么需要使用双亲委托机制</h3><ul><li>可以避免重复加载类，如<code>System.out.println(&quot;ss&quot;)</code>，如果重复调用重复加载多份System类的字节码，就浪费资源了；</li><li>出于安全考虑，如果不采用这种机制就可以让JVM随意调用类，有可能覆盖JDK内部定义的类，存在很大安全问题。</li></ul><h2 id="Java反射"><a href="#Java反射" class="headerlink" title="Java反射"></a>Java反射</h2><p>Java反射是在运行状态中，对任意一个类都能知道这个类的所有属性和方法；对任意一个对象，都能调用这个它的任意方法和属性；这种能够动态获取信息以及动态调用对象方法的功能称为Java语言的反射机制。</p><p>实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ryz.javabasic.reflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectSample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException, NoSuchFieldException </span>&#123;</span><br><span class="line">        Class rc = Class.forName(<span class="string">&quot;com.ryz.javabasic.reflect.Robot&quot;</span>);</span><br><span class="line">        Robot r = (Robot)rc.getDeclaredConstructor().newInstance();</span><br><span class="line">        System.out.println(<span class="string">&quot;Class name is &quot;</span> + rc.getName());</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * getDeclaredMethod可以获取类中包括私有的所有方法，但不能获取继承的</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Method getHello = rc.getDeclaredMethod(<span class="string">&quot;throwHello&quot;</span>, String.class);</span><br><span class="line">        <span class="comment">//私有方法需要设置Accessible</span></span><br><span class="line">        getHello.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Object str = (String) getHello.invoke(r,<span class="string">&quot;test&quot;</span>);</span><br><span class="line">        System.out.println(str);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * getMethod不可以获取私有方法，但是可以获取继承的方法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Method sayHi = rc.getMethod(<span class="string">&quot;sayHi&quot;</span>, String.class);</span><br><span class="line">        sayHi.invoke(r,<span class="string">&quot;welcome&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 类中变量的获取与设置</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Field f = rc.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        f.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        f.set(r,<span class="string">&quot;小明&quot;</span>);</span><br><span class="line">        sayHi.invoke(r,<span class="string">&quot;welcome&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="为什么要用到反射"><a href="#为什么要用到反射" class="headerlink" title="为什么要用到反射"></a>为什么要用到反射</h3><ol><li><p>提高程序的灵活性<br> 比如写JDBC的时候，使用配置文件获取配置加载驱动，就是用过反射加载。</p></li><li><p>屏蔽细节，方便实用<br> 使用Spring的时候用XML注入就用到反射机制</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;引子————谈到Java你会想到什么&quot;&gt;&lt;a href=&quot;#引子————谈到Java你会想到什么&quot; class=&quot;headerlink&quot; title=&quot;引子————谈到Java你会想到什么&quot;&gt;&lt;/a&gt;引子————谈到Java你会想到什么&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;</summary>
      
    
    
    
    
    <category term="Java" scheme="http://ryziii.github.io/tags/Java/"/>
    
    <category term="interview" scheme="http://ryziii.github.io/tags/interview/"/>
    
    <category term="JVM" scheme="http://ryziii.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>interview 笔记备份</title>
    <link href="http://ryziii.github.io/post/38e3a3e6.html"/>
    <id>http://ryziii.github.io/post/38e3a3e6.html</id>
    <published>2020-12-06T14:02:35.000Z</published>
    <updated>2020-12-08T13:59:46.537Z</updated>
    
    <content type="html"><![CDATA[<h4 id="9-接口和抽象类有什么不同？"><a href="#9-接口和抽象类有什么不同？" class="headerlink" title="9.接口和抽象类有什么不同？"></a>9.接口和抽象类有什么不同？</h4><p>Java同时提供和支持抽象类和接口，它们的实现有一些共同的特点，也有如下不同：</p><ul><li>接口中所有的方法默认都是抽象的，而抽象类可以同时包含抽象和非抽象的方法。</li><li>一个类可以实现多个接口，但它只能继承一个抽象类。</li><li>一个类要实现某个接口，必须实现这个接口声明的所有方法。而一个类不需要实现抽象父类中声明的所有方法，不过，这时候这个类也必须声明为抽象类。</li><li>抽象类可以实现接口，而且不需要实现接口中的方法。</li><li>接口中声明的变量默认是final的，而抽象类可以包含非final的变量。</li><li>接口中的成员默认是public的，而抽象类的成员可以是private，protected，或public的。</li><li>接口是绝对抽象的，不可实例化，抽象类也不可以实例化，但可以在main方法中触发实例化（注：通过匿名类实现）。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;9-接口和抽象类有什么不同？&quot;&gt;&lt;a href=&quot;#9-接口和抽象类有什么不同？&quot; class=&quot;headerlink&quot; title=&quot;9.接口和抽象类有什么不同？&quot;&gt;&lt;/a&gt;9.接口和抽象类有什么不同？&lt;/h4&gt;&lt;p&gt;Java同时提供和支持抽象类和接口，它们的实</summary>
      
    
    
    
    
    <category term="Java" scheme="http://ryziii.github.io/tags/Java/"/>
    
    <category term="interview" scheme="http://ryziii.github.io/tags/interview/"/>
    
  </entry>
  
  <entry>
    <title>interview Shell指令</title>
    <link href="http://ryziii.github.io/post/a1bbe4a9.html"/>
    <id>http://ryziii.github.io/post/a1bbe4a9.html</id>
    <published>2020-12-04T08:57:04.000Z</published>
    <updated>2020-12-14T13:52:02.671Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux体系结构"><a href="#Linux体系结构" class="headerlink" title="Linux体系结构"></a>Linux体系结构</h1><p>Linux体系结构主要分为用户态（用户上层活动）和内核态</p><p>内核：本质上是一段管理计算机硬件设备的程序<br>系统调用：内核的访问接口<br>公共函数库：是对系统调用的封装，方便程序使用<br>shell：是命令解释器，功能强大，可编程</p><h1 id="Linux指令"><a href="#Linux指令" class="headerlink" title="Linux指令"></a>Linux指令</h1><h2 id="find"><a href="#find" class="headerlink" title="find"></a>find</h2><p><code>find / -name &quot;**&quot;</code></p><p>-iname 不区分大小写</p><h2 id="grep-与-管道操作符"><a href="#grep-与-管道操作符" class="headerlink" title="grep 与 管道操作符 |"></a>grep 与 管道操作符 |</h2><img src="https://i.imgur.com/Zaibu5i.png" width="650px" ><p>管道操作符可以连接各个指令，管道操作符左边的指令输出是右边指令的输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 包含<span class="built_in">test</span>[正则]的文段</span><br><span class="line">grep -o <span class="string">&#x27;test[正则]&#x27;</span> </span><br><span class="line"><span class="comment">#</span></span><br><span class="line">//不包含<span class="built_in">test</span>[正则]的文段</span><br><span class="line">grep -v <span class="string">&#x27;test[正则]&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h2><p>awk是对文件分割查找的命令，默认的分隔符是空格，可以使用<code>-F &quot;,&quot;</code>来改变分隔符 </p><img src="https://i.imgur.com/YdUvDGe.png" width="650px" ><p>添加表头的命令为NR</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">&#x27;($1==&quot;test1&quot; &amp;&amp; $2==&quot;test31&quot;) || NR==1 &#123;print $0&#125;&#x27;</span> netstat.txt</span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/nwgWIS3.png" alt="nwgWIS3"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">&#x27;arr[$1]++&#125;END&#123;for(i in arr)print i &quot;\t&quot; arr[i]&#125;</span></span><br></pre></td></tr></table></figure><h2 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h2><p>sed(stream editor) 流编辑器，常用于字符串替换、删除、修改</p><img src="https://i.imgur.com/SiQBt5g.png" width="650px" ><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 替换</span></span><br><span class="line">sed -i <span class="string">&#x27;s/^Str/String/&#x27;</span> replace.txt     替换以Str开头的字符串为String</span><br><span class="line">sed -i <span class="string">&#x27;s/\.$/\;/&#x27;</span> replace.txt          替换以<span class="string">&#x27;.&#x27;</span>为结尾的字符串为<span class="string">&#x27;;&#x27;</span></span><br><span class="line">sed -i <span class="string">&#x27;s/Jack/me/g&#x27;</span> replace.txt        全局替换<span class="string">&#x27;Jack&#x27;</span>为<span class="string">&#x27;me&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除</span></span><br><span class="line">sed -i <span class="string">&#x27;/Integer/d&#x27;</span> replace.txt         删除Integer所在的行</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Linux体系结构&quot;&gt;&lt;a href=&quot;#Linux体系结构&quot; class=&quot;headerlink&quot; title=&quot;Linux体系结构&quot;&gt;&lt;/a&gt;Linux体系结构&lt;/h1&gt;&lt;p&gt;Linux体系结构主要分为用户态（用户上层活动）和内核态&lt;/p&gt;
&lt;p&gt;内核：本质上</summary>
      
    
    
    
    
    <category term="interview" scheme="http://ryziii.github.io/tags/interview/"/>
    
    <category term="Linux" scheme="http://ryziii.github.io/tags/Linux/"/>
    
    <category term="Shell" scheme="http://ryziii.github.io/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>interview Redis</title>
    <link href="http://ryziii.github.io/post/912e298.html"/>
    <id>http://ryziii.github.io/post/912e298.html</id>
    <published>2020-11-23T10:04:52.000Z</published>
    <updated>2020-12-08T13:59:46.536Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Redis介绍"><a href="#Redis介绍" class="headerlink" title="Redis介绍"></a>Redis介绍</h2><h3 id="为什么Redis这么快"><a href="#为什么Redis这么快" class="headerlink" title="为什么Redis这么快"></a>为什么Redis这么快</h3><ul><li>完全基于内存，绝大部分请求是内存操作，执行效率高</li><li>数据结构简单，对数据操作也简单</li><li>采用单线程，单线程也能处理高并发请求，想多核也可以启动多实例</li><li>采用多路I/O复用，非阻塞I/O</li></ul><h3 id="Redis提供的数据类型"><a href="#Redis提供的数据类型" class="headerlink" title="Redis提供的数据类型"></a>Redis提供的数据类型</h3><ul><li><p>String： 基本数据类型</p></li><li><p>Hash： String元素组成的字典，适合用于存储对象</p><pre><code>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; </span><br><span class="line">hmset lilei age 11 name &#39;Lilei&#39;</span><br><span class="line">hset lilei age 12</span><br><span class="line">hget lilei age</span><br></pre></td></tr></table></figure></code></pre></li><li><p>List： 列表，按照String元素插入顺序排序</p><pre><code>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lpush mylist aaa</span><br><span class="line">lpush mylist bbb</span><br><span class="line">lrange mylist 0 100</span><br></pre></td></tr></table></figure></code></pre></li><li><p>Set： String元素组成的无序集合，通过哈希表实现，不允许重复</p><pre><code>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; set是无序的</span><br><span class="line">sadd myset 11</span><br><span class="line">sadd myset aa</span><br><span class="line">smembers myset</span><br></pre></td></tr></table></figure></code></pre></li><li><p>Sorted Set： 通过分数来为集合中的成员进行从小到大排序</p><pre><code>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; zset比set多了一个权重参数</span><br><span class="line">127.0.0.1:6379&gt; zadd myzset 3 abc</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; zadd myzset 1 ab</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; zadd myzset 2 andn</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; zadd myzset 2 andn</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; zadd myzset 2 andnn</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; zrangebyscore myzset 0 10</span><br><span class="line">1) &quot;ab&quot;</span><br><span class="line">2) &quot;andn&quot;</span><br><span class="line">3) &quot;andnn&quot;</span><br><span class="line">4) &quot;abc&quot; </span><br></pre></td></tr></table></figure></code></pre></li><li><p>用于计数的HyperLogLog</p></li><li><p>用于存储地理位置信息的Geo</p></li></ul><h3 id="从Redis中找到某一固定前缀的Key"><a href="#从Redis中找到某一固定前缀的Key" class="headerlink" title="从Redis中找到某一固定前缀的Key"></a>从Redis中找到某一固定前缀的Key</h3><ul><li>Keys *返回全部，可能会阻塞服务器</li><li>使用SCAN cursor [MATCH pattern] [COUNT count]<ol><li>基于光标的迭代器，需要给予上一次的光标延续之前的迭代过程</li><li>以0作为光标开始的一次新的迭代，知道命令返回光标0完成一次遍历</li><li>不保证每次执行都反悔某个COUNT指令给定数量的元素，支持模糊查询</li><li>一次返回的数量不可控，只能大概率符合count参数</li></ol></li></ul><h2 id="通过Redis实现分布式锁"><a href="#通过Redis实现分布式锁" class="headerlink" title="通过Redis实现分布式锁"></a>通过Redis实现分布式锁</h2><h3 id="分布式锁需要解决的问题"><a href="#分布式锁需要解决的问题" class="headerlink" title="分布式锁需要解决的问题"></a>分布式锁需要解决的问题</h3><ul><li>互斥性：只能有一个客户端获取锁</li><li>安全性：锁只能被持有该锁的客户端删除不能由其他客户端删除</li><li>死锁：需要有机制避免持有此锁的客户端当机而发生的其他客户端也无法获取此锁的</li><li>容错：服务器宕机后客户端依然能获取锁释放锁</li></ul><h3 id="SETNX-key-value"><a href="#SETNX-key-value" class="headerlink" title="SETNX key value"></a>SETNX key value</h3><p>SETNX命令：</p><ul><li><p>SETNX是原子操作</p></li><li><p>时间复杂度为O(1)</p></li><li><p>返回值：设置成功返回1，设置失败返回0</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; get locknx</span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379&gt; setnx locknx test</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; setnx locknx taks</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; get locknx</span><br><span class="line">&quot;test&quot;</span><br></pre></td></tr></table></figure></li></ul><p>因为SETNX具有如上特点所以经常被用作分布式锁，但SETNX设置后长期有效，所以可以使用EXPIRE指令</p><h3 id="EXPIRE-key-seconds"><a href="#EXPIRE-key-seconds" class="headerlink" title="EXPIRE key seconds"></a>EXPIRE key seconds</h3><p>EXPIRE指令用于设置key的生存时间，当key过期时(生存时间为0)，将会被自动删除</p><h3 id="SETNX与EXPIRE原子性"><a href="#SETNX与EXPIRE原子性" class="headerlink" title="SETNX与EXPIRE原子性"></a>SETNX与EXPIRE原子性</h3><p>SETNX与EXPIRE指令操作都满足原子性，但被用作分布式锁操作时将两个操作合并在一起就不符合原子性了。使用SET key value [EX seconds] [PX milliseconds] [NX|XX]即可解决。 </p><h3 id="SET-key-value-EX-seconds-PX-milliseconds-NX-XX"><a href="#SET-key-value-EX-seconds-PX-milliseconds-NX-XX" class="headerlink" title="SET key value [EX seconds] [PX milliseconds] [NX|XX]"></a>SET key value [EX seconds] [PX milliseconds] [NX|XX]</h3><ul><li><p>EX seconds: 设置键的过期时间是秒</p></li><li><p>PX milliseconds: 设置键的过期时间是毫秒</p></li><li><p>NX: 如果键不存在则设置延迟</p></li><li><p>XX: 如果键存在才设置延迟</p></li><li><p>SET操作成功返回OK，否则返回nil</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set locktarget 123 ex 10 nx</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get locktarget</span><br><span class="line">&quot;123&quot;</span><br><span class="line">127.0.0.1:6379&gt; set locktarget 123 ex 10 nx</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure></li></ul><h3 id="怎么避免大量key同时过期"><a href="#怎么避免大量key同时过期" class="headerlink" title="怎么避免大量key同时过期"></a>怎么避免大量key同时过期</h3><p>redis大量key删除key需要耗费资源，大量key同时过期可能造成卡顿，此时新的请求就会向后端数据库获取数据，对数据库造成很大压力。</p><p>解决办法：</p><ol><li>设置key过期时间时，给key加上随机值</li><li>做二级缓存，A1为原始缓存，A2为二级缓存，A1失效时可以访问A2，A1过期时间为短期，A2位长期</li><li>在缓存失效后，通过加锁或队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据库和写缓存，其他线程等待。</li></ol><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p>一般的缓存系统都是从通过key查找value，如果找不到value则从数据库查找。某些恶意请求会故意查询许多不存在缓存中的key以此来攻击后端数据库系统。对后端压力很大，这就叫缓存穿透。</p><p>解决办法：</p><ol><li>对查询结果为空的key也进行缓存，设置缓存时间短一点。</li><li>对一些一定不存在的key做过滤，存在一个大的bitmap中，查询时对bitmap进行过滤。</li></ol><h2 id="如何使用Redis实现异步队列"><a href="#如何使用Redis实现异步队列" class="headerlink" title="如何使用Redis实现异步队列"></a>如何使用Redis实现异步队列</h2><h3 id="使用List"><a href="#使用List" class="headerlink" title="使用List"></a>使用List</h3><p>使用List作为队列，RPUSH生产消息，LPOP消费消息</p><p>缺点: 如果队列中的值都被消费完，那将出现没有等待队列中有值就消费的情况<br>解决上述缺点: </p><ol><li>可以在应用层引入Sleep机制去调用LPOP重试</li><li>不想使用Sleep机制，可以使用BLPOP key [key …] timeout (阻塞直到队列有消息或超时)，但因其阻塞的特性使其只能提供一个消费者消费</li><li>使用pub/sub订阅者模式解决上述问题，但该模式的发布是无状态的，无法保证可达，如果客户端下线再重新上线则无法收到之前的消息。</li><li>解决上述问题可以使用专业的消息队列中间件，如Kafka等</li></ol><h2 id="Redis-RDB持久化"><a href="#Redis-RDB持久化" class="headerlink" title="Redis RDB持久化"></a>Redis RDB持久化</h2><h3 id="Redis-RDB持久化方法"><a href="#Redis-RDB持久化方法" class="headerlink" title="Redis RDB持久化方法"></a>Redis RDB持久化方法</h3><p>RDB(Redis DataBase)快照持久化：保存某个时间点的全部数据快照。<br>此功能由redis.conf中的指令控制，在conf中常用到的指令有： </p><ul><li>SAVE: 阻塞redis服务器进程，直到RDB文件被创建完成</li><li>BGSAVE: Fork出一个子进程来创建RDB文件，不阻塞服务器进程</li></ul><h4 id="BGSAVE原理"><a href="#BGSAVE原理" class="headerlink" title="BGSAVE原理"></a>BGSAVE原理</h4><p><img src="https://i.imgur.com/tGWjEg1.png" alt="tGWjEg1"><br>当系统调用fork()时，创建进程实现Copy-on-Write</p><h5 id="什么是Copy-on-Write"><a href="#什么是Copy-on-Write" class="headerlink" title="什么是Copy-on-Write"></a>什么是Copy-on-Write</h5><p>当有多个调用者请求调用相同资源(在内存或者磁盘上的数据储存)，他们会获取相同的指向该资源的指针，直到某个调用者试图修改资源的内容时，系统才会真正的复制一份副本给该调用者，而其他调用者所见的最初的资源仍保持不变。</p><h3 id="自动化触发RDB持久化的方式"><a href="#自动化触发RDB持久化的方式" class="headerlink" title="自动化触发RDB持久化的方式"></a>自动化触发RDB持久化的方式</h3><ol><li>根据redis.conf配置里的SAVE m n定时触发(用的是BGSAVE)</li><li>主从复制时，主节点自动触发</li><li>执行Debug Reload</li><li>执行Shutdown且没有开启AOF持久化</li></ol><p>RDB持久化参考文章 <a href="https://juejin.cn/post/6844903886189395982">https://juejin.cn/post/6844903886189395982</a></p><h3 id="RDB持久化的缺点"><a href="#RDB持久化的缺点" class="headerlink" title="RDB持久化的缺点"></a>RDB持久化的缺点</h3><ol><li>内存数据的全量同步，数据量大会由于I/O而严重影响性能</li><li>当redis突然挂掉的话，会丢失上次快照到当前时间的数据</li></ol><h2 id="Redis-AOF持久化"><a href="#Redis-AOF持久化" class="headerlink" title="Redis AOF持久化"></a>Redis AOF持久化</h2><h3 id="Reis-AOF是如何做持久化的"><a href="#Reis-AOF是如何做持久化的" class="headerlink" title="Reis AOF是如何做持久化的"></a>Reis AOF是如何做持久化的</h3><p>AOF(Append-Only-File)持久化: 保存写状态</p><ul><li>记录下除了了查询之外的左右变成数据库状态的指令</li><li>以append的形式追加到AOF文件中(增量)</li></ul><h3 id="日志重写结局AOF文件大小不断增大的问题"><a href="#日志重写结局AOF文件大小不断增大的问题" class="headerlink" title="日志重写结局AOF文件大小不断增大的问题"></a>日志重写结局AOF文件大小不断增大的问题</h3><ul><li>因为Reids会不断地往AOF文件中新增执行的命令记录，所以AOF文件在不断增大。极端情况下有可能占满磁盘可用空间</li><li>Redis重启后需要重新执行AOF文件中的命令以此来还原数据集，所以如果AOF文件越大则开启Redis后所需的等待时间就越长。</li></ul><p>为解决此问题，用户可以向Redis发送BGREWRITEAOF命令，这个命令会通过移除AOF文件的冗余来使AOF文件尽可能小。BGREWRITEAOF的原理同RDB持久化BGSAVE相同也需要用到Copy-On-Write特性，BGREWRITEAOF命令原理如下: </p><ol><li>调用fork()，创建一个子进程</li><li>子进程把新的AOF文件写进一个临时文件中，不依赖原来的AOF文件</li><li>主进程持续将新的变动同时写进内存和原来的AOF里</li><li>主进程获取子进程重写AOF的完成信号，往新的AOF同步增量变动</li><li>使用新的AOF文件替换掉旧的AOF文件</li></ol><h3 id="Reids持久化RDB与AOF对比"><a href="#Reids持久化RDB与AOF对比" class="headerlink" title="Reids持久化RDB与AOF对比"></a>Reids持久化RDB与AOF对比</h3><p>RDB优缺点: 本质上是内存备份，RDB的优点在于全量备份文件小恢复快，缺点在于无法保存创建RDB文件之后的增量数据<br>AOF优缺点: 本质上是一份执行日志，优点在于可读性高，适合保存增量数据，数据不易丢失，缺点在于文件体积大，做日志回放恢复时间较长</p><h3 id="RDB-AOF混合持久化方式"><a href="#RDB-AOF混合持久化方式" class="headerlink" title="RDB-AOF混合持久化方式"></a>RDB-AOF混合持久化方式</h3><p>使用RDB做全量持久化，用AOF做增量持久化</p><h2 id="Redis同步机制"><a href="#Redis同步机制" class="headerlink" title="Redis同步机制"></a>Redis同步机制</h2><h3 id="Redis-Pipeline"><a href="#Redis-Pipeline" class="headerlink" title="Redis Pipeline"></a>Redis Pipeline</h3><p>Redis的get操作是阻塞的，使用Pipeline可以批量执行命令，节省多次IO往返的时间。</p><h3 id="流言协议Gossip"><a href="#流言协议Gossip" class="headerlink" title="流言协议Gossip"></a>流言协议Gossip</h3><p>流言协议指的是随机在系统中传播信息，并在一定时间内使得整个系统节点的信息保持一致。</p><ul><li>每个节点都能随即地与对方通信，最终所有节点的状态达成一致。</li><li>种子节点定期随机向其他节点发送节点列表以及需要传播的信息。</li><li>不保证信息一定会传递给所有节点，但是最终会趋于一致。</li></ul><h2 id="Redis集群"><a href="#Redis集群" class="headerlink" title="Redis集群"></a>Redis集群</h2><p>Redis集群参考<a href="https://juejin.cn/post/6850418113830846471">此篇文章</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Redis介绍&quot;&gt;&lt;a href=&quot;#Redis介绍&quot; class=&quot;headerlink&quot; title=&quot;Redis介绍&quot;&gt;&lt;/a&gt;Redis介绍&lt;/h2&gt;&lt;h3 id=&quot;为什么Redis这么快&quot;&gt;&lt;a href=&quot;#为什么Redis这么快&quot; class=&quot;he</summary>
      
    
    
    
    
    <category term="interview" scheme="http://ryziii.github.io/tags/interview/"/>
    
    <category term="Redis" scheme="http://ryziii.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>interview 数据库相关</title>
    <link href="http://ryziii.github.io/post/df0d4913.html"/>
    <id>http://ryziii.github.io/post/df0d4913.html</id>
    <published>2020-10-27T05:41:36.000Z</published>
    <updated>2020-12-08T13:59:46.537Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关系型数据库基本架构"><a href="#关系型数据库基本架构" class="headerlink" title="关系型数据库基本架构"></a>关系型数据库基本架构</h2><p><img src="https://i.imgur.com/Uq2eYn9.jpg"></p><h3 id="关系数据库索引所采取的数据结构"><a href="#关系数据库索引所采取的数据结构" class="headerlink" title="关系数据库索引所采取的数据结构"></a>关系数据库索引所采取的数据结构</h3><h4 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B Tree"></a>B Tree</h4><p><img src="https://i.imgur.com/0jVQ0S3.jpg"></p><h4 id="B-Tree-1"><a href="#B-Tree-1" class="headerlink" title="B+ Tree"></a>B+ Tree</h4><p><img src="https://i.imgur.com/jqDubwu.jpg"></p><h4 id="密集索引和稀疏索引"><a href="#密集索引和稀疏索引" class="headerlink" title="密集索引和稀疏索引"></a>密集索引和稀疏索引</h4><p>密集索引：文件中每个搜索码值都对应一个索引值<br>稀疏索引：文件只为索引码的某些值建立索引项 </p><h5 id="为什么要使用索引"><a href="#为什么要使用索引" class="headerlink" title="为什么要使用索引"></a>为什么要使用索引</h5><p>使用索引可以避免全表扫描，可以提升效率</p><h5 id="什么样的信息能成为索引"><a href="#什么样的信息能成为索引" class="headerlink" title="什么样的信息能成为索引"></a>什么样的信息能成为索引</h5><p>唯一键、主键、能将信息区分开的字段</p><h5 id="索引的数据结构"><a href="#索引的数据结构" class="headerlink" title="索引的数据结构"></a>索引的数据结构</h5><p>主流是B+Tree，还有哈希、bitmap等，MySql不支持bitmap，Inodb和MyISAM不支持哈希</p><h3 id="如何定位并优化慢查询Sql"><a href="#如何定位并优化慢查询Sql" class="headerlink" title="如何定位并优化慢查询Sql"></a>如何定位并优化慢查询Sql</h3><ol><li>根据慢查询日志定位慢查询sql</li><li>使用explain等工具分析sql</li><li>修改sql或者尽量让sql走索引</li></ol><h3 id="联合索引的最左匹配原则"><a href="#联合索引的最左匹配原则" class="headerlink" title="联合索引的最左匹配原则"></a>联合索引的最左匹配原则</h3><h4 id="什么是最左匹配原则"><a href="#什么是最左匹配原则" class="headerlink" title="什么是最左匹配原则"></a>什么是最左匹配原则</h4><p>mysql会一直向右匹配直到遇到范围查询（&gt;、&lt;、between、like）就停止匹配，比如a = 3 and b = 5 and c &gt; 5 and d = 6 如果建立(a,b,c,d)顺序的索引，d是用不到索引的</p><h4 id="联合索引的最左匹配原则成因"><a href="#联合索引的最左匹配原则成因" class="headerlink" title="联合索引的最左匹配原则成因"></a>联合索引的最左匹配原则成因</h4><p>最左前缀匹配成因：mysql 是创建复合索引的规则是根据索引最左边的字段进行排序，在第一个字段排序的基础上再进行第二个字段排序，类似于order by col1，col2… 所以第一个字段是绝对有序的 第二个字段就是无序的了，所以mysql 强调最左前缀匹配</p><h2 id="锁模块"><a href="#锁模块" class="headerlink" title="锁模块"></a>锁模块</h2><h3 id="写锁和读锁"><a href="#写锁和读锁" class="headerlink" title="写锁和读锁"></a>写锁和读锁</h3><p>读锁是共享锁，读锁上时不影响其他select读语句<br>写锁是排他锁，写锁上时其他写入语句别block住</p><blockquote><p>innodb默认支持行级锁</p></blockquote><h2 id="数据库事务的四大特性"><a href="#数据库事务的四大特性" class="headerlink" title="数据库事务的四大特性"></a>数据库事务的四大特性</h2><p>ACID</p><ul><li>原子性（Atomic）</li><li>一致性（Consistency）</li><li>隔离性（Isolation）</li><li>持久性（Durability）</li></ul><h2 id="Mysql复杂语句"><a href="#Mysql复杂语句" class="headerlink" title="Mysql复杂语句"></a>Mysql复杂语句</h2><p>GROUP BY</p><ul><li>满足’SELECT子句中的列名必须为分组列或列函数’</li><li>列函数对group by定义的每个组各返回一个结果 </li></ul><p>HAVING</p><ul><li>having通常与group by一起使用</li><li>where是用来过滤行，having用来过滤组</li><li>同一个sql语句中出现的顺序是：WHERE &gt; GROUP BY &gt; HAVING</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;关系型数据库基本架构&quot;&gt;&lt;a href=&quot;#关系型数据库基本架构&quot; class=&quot;headerlink&quot; title=&quot;关系型数据库基本架构&quot;&gt;&lt;/a&gt;关系型数据库基本架构&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/Uq2eYn9.</summary>
      
    
    
    
    
    <category term="Mysql" scheme="http://ryziii.github.io/tags/Mysql/"/>
    
    <category term="interview" scheme="http://ryziii.github.io/tags/interview/"/>
    
  </entry>
  
  <entry>
    <title>interview HTTP协议相关</title>
    <link href="http://ryziii.github.io/post/28a3ef0.html"/>
    <id>http://ryziii.github.io/post/28a3ef0.html</id>
    <published>2020-10-22T12:30:49.000Z</published>
    <updated>2020-12-08T13:52:20.281Z</updated>
    
    <content type="html"><![CDATA[<h3 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h3><h4 id="HTTP协议特点"><a href="#HTTP协议特点" class="headerlink" title="HTTP协议特点"></a>HTTP协议特点</h4><ul><li>支持客户/服务器模式：浏览器向服务器请求</li><li>简单快速：get、post…</li><li>灵活：允许传输任意类型数据</li><li>无连接：请求结束后断开连接</li><li>无状态：不保留状态，之后的事务不知道之前的事</li></ul><h4 id="HTTP协议请求-响应步骤"><a href="#HTTP协议请求-响应步骤" class="headerlink" title="HTTP协议请求/响应步骤"></a>HTTP协议请求/响应步骤</h4><ol><li>客户端连接到Web服务器</li><li>客户端发送HTTP请求</li><li>服务器接受请求并返回HTTP响应</li><li>关闭TCP连接</li><li>客户端解析HTML</li></ol><h4 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h4><ol><li>1XX：提示信息</li><li>2XX：成功</li><li>3XX：重定向</li><li>4XX：客户端错误</li><li>5XX：服务端错误 </li></ol><h3 id="Cookie与Session"><a href="#Cookie与Session" class="headerlink" title="Cookie与Session"></a>Cookie与Session</h3><h4 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h4><p>服务器发给客户的信息，客户端以文本的形式保存在本地<br>Cookie的设置过程：<br><img src="https://i.imgur.com/2A4VivD.jpg"></p><h4 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h4><p>保存在服务器上<br>Session实现方式：<br><img src="https://i.imgur.com/SVAxPO9.jpg"></p><ol><li>使用Cookie实现：在Cookie中写入SessionID，这样在服务端和客户端交互时就带有SessionID</li><li>使用URL回写：服务器发给客户端页面中所有连接都带有SessionID，这样在浏览器点击任何一个URL时都会带回SessionID</li></ol><h4 id="Cookie与Session的区别"><a href="#Cookie与Session的区别" class="headerlink" title="Cookie与Session的区别"></a>Cookie与Session的区别</h4><ul><li>Cookie存储在客户端浏览器上，Session存储在服务器上</li><li>Session比Cookie安全（因为Cookie存放在本地，可以被人本地分析）</li><li>Session因为存放在服务器上所以会影响服务器性能，为减轻服务器开销应当使用Cookie</li></ul><h3 id="GET和POST请求的区别"><a href="#GET和POST请求的区别" class="headerlink" title="GET和POST请求的区别"></a>GET和POST请求的区别</h3><ul><li> HTTP报文层面：GET将请求信息放入URL，POST将请求信息放入报文体(bodyw)内（GET请求信息长度理论上不受限制，但实际上受浏览器客户端的限制）</li><li> 数据库层面：GET符合幂等性和安全性，POST不符合（因为GET是做查询，不影响数据库）</li><li> 其他层面：GET可以被缓存、被存储，POST不行</li></ul><h3 id="HTTP和HTTPS"><a href="#HTTP和HTTPS" class="headerlink" title="HTTP和HTTPS"></a>HTTP和HTTPS</h3><p>HTTPS为更安全的HTTP，比HTTP多了SSL</p><h4 id="SSL是什么"><a href="#SSL是什么" class="headerlink" title="SSL是什么"></a>SSL是什么</h4><p><img src="https://i.imgur.com/2d8R8ou.jpg"></p><h4 id="几类常见的加密方式"><a href="#几类常见的加密方式" class="headerlink" title="几类常见的加密方式"></a>几类常见的加密方式</h4><ul><li>对称加密：加解密使用同一个密钥</li><li>非对称加密：加解密使用的密钥都不用</li><li>哈希算法：将任意长度信息转换为固定长度的值，算法不可逆</li><li>数字签名：将签名加密附在信息中</li></ul><h4 id="HTTPS传输流程"><a href="#HTTPS传输流程" class="headerlink" title="HTTPS传输流程"></a>HTTPS传输流程</h4><ol><li>客户端将支持的加密算法信息发送给服务器</li><li>服务器选择一套客户端支持的加密算法，以证书的方式回发客户端</li><li>客户端验证证书的合法性，并结合证书公钥加密信息发送给服务器</li><li>服务器使用私钥揭秘信息，验证哈希，加密响应消息回发给客户端</li><li>客户端解密响应消息，并对消息进行验真，之后进行加密交互数据</li></ol><h4 id="HTTPS和HTTP区别"><a href="#HTTPS和HTTP区别" class="headerlink" title="HTTPS和HTTP区别"></a>HTTPS和HTTP区别</h4><ul><li>HTTPS需要到CA申请证书</li><li>HTTPS是密文传输，HTTP是明文传输（因为HTTPS经过SSL加密）</li><li>HTTPS使用的是443端口，HTTP使用80</li><li>HTTPS=HTTP+加密+认证+完整性保护</li></ul><h4 id="HTTPS真的安全吗"><a href="#HTTPS真的安全吗" class="headerlink" title="HTTPS真的安全吗"></a>HTTPS真的安全吗</h4><p>在浏览器上输入url时如果不输入https，则浏览器默认填充http，一般网站使用http跳转https，这时就容易受到攻击，应该使用HSTS标准优化</p><h5 id="HSTS"><a href="#HSTS" class="headerlink" title="HSTS"></a>HSTS</h5><p>HSTS（HTTP Strict Transport Security）是严格传输安全的缩写。<br>如果一个网站生命HSTS策略，则浏览器必须拒绝所有HTTP连接并阻止用户接受不安全的SSL证书。</p><h3 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h3><h4 id="Socket通信过程"><a href="#Socket通信过程" class="headerlink" title="Socket通信过程"></a>Socket通信过程</h4><p><img src="https://i.imgur.com/vFPDreT.jpg"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;HTTP协议&quot;&gt;&lt;a href=&quot;#HTTP协议&quot; class=&quot;headerlink&quot; title=&quot;HTTP协议&quot;&gt;&lt;/a&gt;HTTP协议&lt;/h3&gt;&lt;h4 id=&quot;HTTP协议特点&quot;&gt;&lt;a href=&quot;#HTTP协议特点&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    
    <category term="interview" scheme="http://ryziii.github.io/tags/interview/"/>
    
    <category term="HTTP" scheme="http://ryziii.github.io/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>interview UDP相关</title>
    <link href="http://ryziii.github.io/post/27e25b32.html"/>
    <id>http://ryziii.github.io/post/27e25b32.html</id>
    <published>2020-10-22T12:17:25.000Z</published>
    <updated>2020-12-08T13:52:27.528Z</updated>
    
    <content type="html"><![CDATA[<h2 id="UDP协议的特点"><a href="#UDP协议的特点" class="headerlink" title="UDP协议的特点"></a>UDP协议的特点</h2><ul><li>UDP面向非连接</li><li>UDP不维护连接状态，支持同事向多个客户端传输相同的消息</li><li>数据包头只有8个字节，额外开销较小</li><li>吞吐量只受限于数据生成速率、传输速率以及机器性能</li><li>UDP不保证可靠交付</li><li>不对应用程序提交豹纹信息进行拆分或合并</li></ul><h3 id="由上结论得出TCP和UDP"><a href="#由上结论得出TCP和UDP" class="headerlink" title="由上结论得出TCP和UDP"></a>由上结论得出TCP和UDP</h3><ul><li>面向连接vs无连接：UDP常用于广播，多播发布，而TCP是面向连接的</li><li>可靠性：UDP无可靠性保证，TCP有握手重出传机制</li><li>有序性：TCP通过序号保证传输数据的有序性，UDP无序</li><li>速度：UDP速度更快，适合视频，游戏</li><li>量级：TCP20字节 UDP8字节</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;UDP协议的特点&quot;&gt;&lt;a href=&quot;#UDP协议的特点&quot; class=&quot;headerlink&quot; title=&quot;UDP协议的特点&quot;&gt;&lt;/a&gt;UDP协议的特点&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;UDP面向非连接&lt;/li&gt;
&lt;li&gt;UDP不维护连接状态，支持同事向多个客户端传</summary>
      
    
    
    
    
    <category term="interview" scheme="http://ryziii.github.io/tags/interview/"/>
    
    <category term="HTTP" scheme="http://ryziii.github.io/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>interview TCP滑动窗口</title>
    <link href="http://ryziii.github.io/post/75d57196.html"/>
    <id>http://ryziii.github.io/post/75d57196.html</id>
    <published>2019-10-10T14:21:01.000Z</published>
    <updated>2020-12-14T14:06:03.662Z</updated>
    
    <content type="html"><![CDATA[<h2 id="RTT和RTO"><a href="#RTT和RTO" class="headerlink" title="RTT和RTO"></a>RTT和RTO</h2><ol><li>RTT是发送一个数据包到收到ACK所花费的时间；</li><li>RTO是重传时间间隔，当没有收到回应是，一定时间间隔后会重传数据包，RTO是根据RTT计算出的。</li></ol><h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><img src="https://i.imgur.com/yNoei6J.png" width="650px" ><img src="https://i.imgur.com/znAiTFe.png" width="650px" ><img src="https://i.imgur.com/XmGyAGr.png" width="650px" ><p>滑动窗口是用于做流量控制和乱序重排。TCP发送方和接收方都维护着一个数据缓存区，发送方缓存区有如下四种状态：</p><ol><li>已发送已收到ACK</li><li>已发送未收到ACK</li><li>未发送可发送</li><li>不可发送</li></ol><p>接收方缓存区有如下三种状态：</p><ol><li>已接收并已回复ACK</li><li>允许接收</li><li>不允许接收</li></ol><blockquote><p><a href="https://www.cnblogs.com/lingyejun/p/7158028.html">参考网址1</a></p><p><a href="https://my.oschina.net/funcy/blog/3006133">参考网址2</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;RTT和RTO&quot;&gt;&lt;a href=&quot;#RTT和RTO&quot; class=&quot;headerlink&quot; title=&quot;RTT和RTO&quot;&gt;&lt;/a&gt;RTT和RTO&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;RTT是发送一个数据包到收到ACK所花费的时间；&lt;/li&gt;
&lt;li&gt;RTO是重传时间间隔</summary>
      
    
    
    
    
    <category term="interview" scheme="http://ryziii.github.io/tags/interview/"/>
    
  </entry>
  
  <entry>
    <title>interview TCP四次挥手</title>
    <link href="http://ryziii.github.io/post/beaf26b1.html"/>
    <id>http://ryziii.github.io/post/beaf26b1.html</id>
    <published>2019-10-10T13:12:24.000Z</published>
    <updated>2020-12-08T14:16:37.721Z</updated>
    
    <content type="html"><![CDATA[<h2 id="TCP四次挥手"><a href="#TCP四次挥手" class="headerlink" title="TCP四次挥手"></a>TCP四次挥手</h2><p><img src="https://ryziii.github.io/post-images/1570713886846.jpeg">[interview] TCP断开连接需要进行“四次挥手”</p><ol><li>Client向Server发送带有FIN包(seq = u)的包，用于关闭Client到Server的数据连接，并进入FIN_WAIT_1状态；</li><li>Server接收到FIN包后向Client发送一个ACK包(ack=u+1,seq=v),并进入CLOSE_WAIT状态,Client收到后进入FIN_WAIT_2;</li><li>待Server发送完数据后，再向Client发送一个FIN+ACK包(seq=w,ack=u+1)，用于关闭Server到Client的数据传送，并进入LAST_ACK状态；</li><li>Client收到FIN报文后进入TIMEWAIT状态，接着向Server发送一个ACK包(ack=w+1,seq=u+1)，Server进入CLOSE状态。</li></ol><blockquote><p>注：Client进入TIMEWAIT状态后2MSL后就进入CLOSE状态，Linux中MSL一般为30s。MSL是为了让Server有足够的时间收到最后一个ACK包。</p></blockquote><h2 id="为什么需要四次挥手"><a href="#为什么需要四次挥手" class="headerlink" title="为什么需要四次挥手"></a>为什么需要四次挥手</h2><p>因为TCP连接是全双工的，所以Client和Server都需要FIN报文和ACK报文。</p><h2 id="服务器出现大量CLISE-WAIT"><a href="#服务器出现大量CLISE-WAIT" class="headerlink" title="服务器出现大量CLISE_WAIT"></a>服务器出现大量CLISE_WAIT</h2><p>因为代码中没有释放资源<br>netstat -n |awk ‘/^tcp/{++S[$NF]}END{for(a in S) print a,S[a]}’</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;TCP四次挥手&quot;&gt;&lt;a href=&quot;#TCP四次挥手&quot; class=&quot;headerlink&quot; title=&quot;TCP四次挥手&quot;&gt;&lt;/a&gt;TCP四次挥手&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://ryziii.github.io/post-images/157</summary>
      
    
    
    
    
    <category term="interview" scheme="http://ryziii.github.io/tags/interview/"/>
    
  </entry>
  
  <entry>
    <title>interview TCP三次握手</title>
    <link href="http://ryziii.github.io/post/56765b2b.html"/>
    <id>http://ryziii.github.io/post/56765b2b.html</id>
    <published>2019-10-10T13:00:00.000Z</published>
    <updated>2020-12-08T14:18:19.269Z</updated>
    
    <content type="html"><![CDATA[<h2 id="三次握手过程"><a href="#三次握手过程" class="headerlink" title="三次握手过程"></a>三次握手过程</h2><p>在TCP/IP协议中，TCP通过三次握手来创建一个可靠的连接。</p><ol><li>第一次握手，发送端向服务器发送SYN包(syn=j)，并进入SYN_SEND状态，等待服务器回应。</li><li>第二次握手，服务器收到发送端发来的SYN包，必须确认发送端的SYN包(ack=j+1)，并发送一个SYN(syn=k),即SYN+ACK包。此时服务器进入SYN_RECIV状态。</li><li>第三次握手，客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1)，此时双方建立连接，进入ESTABLISHED状态，完成三次握手。</li></ol><h2 id="为什么需要三次握手？"><a href="#为什么需要三次握手？" class="headerlink" title="为什么需要三次握手？"></a>为什么需要三次握手？</h2><p>为了初始化Sequence Number，防止后续建立连接后发送数据乱序</p><h2 id="SYN超时隐患"><a href="#SYN超时隐患" class="headerlink" title="SYN超时隐患"></a>SYN超时隐患</h2><p>Server收到Client的SYN，发送SYN-ACK后未收到CLient的ACK确认，Server会不断重试直至超时，Linux默认63s<br>SYN超时会造成Server在时间内才会断开连接，攻击者会让服务器无法处理正常连接请求。Linux会构造一个SYNcookie只有请求者可以回复，防止被恶意进攻</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;三次握手过程&quot;&gt;&lt;a href=&quot;#三次握手过程&quot; class=&quot;headerlink&quot; title=&quot;三次握手过程&quot;&gt;&lt;/a&gt;三次握手过程&lt;/h2&gt;&lt;p&gt;在TCP/IP协议中，TCP通过三次握手来创建一个可靠的连接。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;第一次握手，发送端</summary>
      
    
    
    
    
    <category term="interview" scheme="http://ryziii.github.io/tags/interview/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 104 递归</title>
    <link href="http://ryziii.github.io/post/bfd03033.html"/>
    <id>http://ryziii.github.io/post/bfd03033.html</id>
    <published>2019-01-25T08:31:30.000Z</published>
    <updated>2020-12-14T13:52:09.404Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接:<a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/">https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/</a></p><p>找树有几层,递归即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root==<span class="keyword">null</span>?<span class="number">0</span>:dfs(root,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode root,<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root.left==<span class="keyword">null</span>&amp;&amp;root.right==<span class="keyword">null</span>) <span class="keyword">return</span> len;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(root.left!=<span class="keyword">null</span>&amp;&amp;root.right==<span class="keyword">null</span>) <span class="keyword">return</span> dfs(root.left,len+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(root.left==<span class="keyword">null</span>&amp;&amp;root.right!=<span class="keyword">null</span>) <span class="keyword">return</span> dfs(root.right,len+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> Math.max(dfs(root.left,len+<span class="number">1</span>),dfs(root.right,len+<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//看到讨论区有个人一行搞定</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root == <span class="keyword">null</span> ? <span class="number">0</span> : Math.max(maxDepth(root.left), maxDepth(root.right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;题目链接:&lt;a href=&quot;https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/&quot;&gt;https://leetcode-cn.com/problems/maximum-depth-of-binary-tr</summary>
      
    
    
    
    
    <category term="leetcode" scheme="http://ryziii.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 107 bfs</title>
    <link href="http://ryziii.github.io/post/d299569f.html"/>
    <id>http://ryziii.github.io/post/d299569f.html</id>
    <published>2019-01-25T08:27:26.000Z</published>
    <updated>2020-12-03T11:19:52.146Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接:<a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/">https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/</a></p><p>从下到上返回每层二叉树的值<br>用bfs</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrderBottom(TreeNode root) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; lists = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        LinkedList&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            queue.add(root);</span><br><span class="line">            List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            res.add(root.val);</span><br><span class="line">            lists.add(res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">int</span> n = queue.size();<span class="comment">//因为是每层的值,所以这里加一个循环</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">                TreeNode a = queue.removeFirst();</span><br><span class="line">                <span class="keyword">if</span> (a.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    res.add(a.left.val);</span><br><span class="line">                    queue.add(a.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (a.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    res.add(a.right.val);</span><br><span class="line">                    queue.add(a.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!res.isEmpty()) lists.add(res);</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.reverse(lists);</span><br><span class="line">        <span class="keyword">return</span> lists;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;题目链接:&lt;a href=&quot;https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/&quot;&gt;https://leetcode-cn.com/problems/binary-tree-level-</summary>
      
    
    
    
    
    <category term="leetcode" scheme="http://ryziii.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 394 栈</title>
    <link href="http://ryziii.github.io/post/745a84ae.html"/>
    <id>http://ryziii.github.io/post/745a84ae.html</id>
    <published>2019-01-24T07:07:07.000Z</published>
    <updated>2020-12-03T11:22:18.542Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接:<a href="https://leetcode-cn.com/problems/decode-string/">https://leetcode-cn.com/problems/decode-string/</a></p><p>这题做了很久,用的递归的思路去解的,发现很痛苦,调试到最后都不知道自己的思路是什么了,懵懵的,过了以后看别人怎么写的,发现优雅的解法应该是用栈模拟</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> String <span class="title">decodeString</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> flag=<span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> c = s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">                <span class="keyword">if</span>(c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (c == <span class="string">&#x27;[&#x27;</span>) &#123;</span><br><span class="line">                    num++;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;]&#x27;</span>) &#123;</span><br><span class="line">                    num--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (num == <span class="number">0</span>) &#123;</span><br><span class="line">                    flag = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">                res.append(pinjie(s.substring(i)));</span><br><span class="line">                flag=<span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(c&gt;=<span class="string">&#x27;a&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;z&#x27;</span>)&#123;</span><br><span class="line">                res.append(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> StringBuilder <span class="title">pinjie</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        StringBuilder ss = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">boolean</span> flag=<span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>(c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">                    ss.append(pinjie(s.substring(i)));</span><br><span class="line">                    <span class="keyword">boolean</span> fl = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">int</span> n=<span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;s.length();j++)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(s.charAt(j)==<span class="string">&#x27;[&#x27;</span>&amp;&amp;!fl)&#123;</span><br><span class="line">                            n++;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span>(s.charAt(j)==<span class="string">&#x27;]&#x27;</span>)&#123;</span><br><span class="line">                            n--;fl=<span class="keyword">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (n == <span class="number">0</span>&amp;&amp;fl) &#123;</span><br><span class="line">                            i=j;<span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    num = num*<span class="number">10</span>+(c-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(!flag)&#123;</span><br><span class="line">                    flag=<span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(c==<span class="string">&#x27;]&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;num;j++)&#123;</span><br><span class="line">                    res.append(ss);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(c==<span class="string">&#x27;[&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">            ss.append(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//优雅版</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">decodeString</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        LinkedList&lt;String&gt; strlist = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        LinkedList&lt;Integer&gt; countlist = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">char</span>[] chars = s.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        StringBuilder sb  = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">while</span>(i&lt;chars.length)&#123;</span><br><span class="line">            <span class="keyword">while</span>(Character.isDigit(chars[i]))&#123;</span><br><span class="line">                sb.append(chars[i++]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!sb.toString().isEmpty())&#123;</span><br><span class="line">                countlist.addLast(Integer.valueOf(sb.toString()));</span><br><span class="line">                sb.delete(<span class="number">0</span>,sb.length());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(i&lt;chars.length&amp;&amp;Character.isLetter(chars[i]))&#123;</span><br><span class="line">                sb.append(chars[i++]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!sb.toString().isEmpty())&#123;</span><br><span class="line">                strlist.addLast(sb.toString());</span><br><span class="line">                sb.delete(<span class="number">0</span>,sb.length());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i&lt;chars.length&amp;&amp;chars[i]==<span class="string">&#x27;[&#x27;</span>)&#123;</span><br><span class="line">                strlist.addLast(<span class="string">&quot;[&quot;</span>);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            String str=<span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="keyword">if</span>(i&lt;chars.length&amp;&amp;chars[i]==<span class="string">&#x27;]&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">while</span>(!strlist.isEmpty()) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(!<span class="string">&quot;[&quot;</span>.equals(strlist.peekLast()))&#123;</span><br><span class="line">                        str = strlist.pollLast()+str;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        strlist.pollLast();</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> count = countlist.removeLast();</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;count;j++)&#123;</span><br><span class="line">                    sb.append(str);</span><br><span class="line">                &#125;</span><br><span class="line">                strlist.addLast(sb.toString());</span><br><span class="line">                sb.delete(<span class="number">0</span>,sb.length());</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (String s1 : strlist) &#123;</span><br><span class="line">            sb.append(s1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;题目链接:&lt;a href=&quot;https://leetcode-cn.com/problems/decode-string/&quot;&gt;https://leetcode-cn.com/problems/decode-string/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这题做了很久,用的递归的思路去</summary>
      
    
    
    
    
    <category term="leetcode" scheme="http://ryziii.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 21 合并链表</title>
    <link href="http://ryziii.github.io/post/ce6d2c02.html"/>
    <id>http://ryziii.github.io/post/ce6d2c02.html</id>
    <published>2019-01-22T10:36:50.000Z</published>
    <updated>2020-10-21T08:21:20.825Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接:<a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/">https://leetcode-cn.com/problems/merge-two-sorted-lists/</a></p><p>想了很久逻辑拐不过弯来,发现数据结构还是要去看一下,最后没写错</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        ListNode li = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode res = li;</span><br><span class="line">        <span class="keyword">if</span>(l1==<span class="keyword">null</span>||l2==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> l1==<span class="keyword">null</span>?l2:l1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(l1!=<span class="keyword">null</span>||l2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l1==<span class="keyword">null</span>)&#123;</span><br><span class="line">                res.next = l2;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">                res = res.next;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(l2==<span class="keyword">null</span>)&#123;</span><br><span class="line">                res.next = l1;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">                res = res.next;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(l1.val&gt;=l2.val)&#123;</span><br><span class="line">                res.next = l2;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">                res = res.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                res.next = l1;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">                res = res.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> li.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//我在发现两个链表不同长时还是一个一个填充,写完后看了眼讨论区,发现两个链表不同长时可以在最后直接填到res.next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        ListNode li = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode res = li;</span><br><span class="line">        <span class="keyword">if</span>(l1==<span class="keyword">null</span>||l2==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> l1==<span class="keyword">null</span>?l2:l1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(l1!=<span class="keyword">null</span>||l2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l1.val&gt;=l2.val)&#123;</span><br><span class="line">                res.next = l2;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">                res = res.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                res.next = l1;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">                res = res.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l1==<span class="keyword">null</span>)&#123;</span><br><span class="line">            res.next = l2;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            res.next = l1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> li.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;题目链接:&lt;a href=&quot;https://leetcode-cn.com/problems/merge-two-sorted-lists/&quot;&gt;https://leetcode-cn.com/problems/merge-two-sorted-lists/&lt;/a&gt;&lt;/p&gt;
</summary>
      
    
    
    
    
    <category term="leetcode" scheme="http://ryziii.github.io/tags/leetcode/"/>
    
  </entry>
  
</feed>
