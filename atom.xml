<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Rysi&#39;s Blog</title>
  
  <subtitle>层楼纵终究误少年，自由早晚乱余生</subtitle>
  <link href="http://ryziii.github.io/atom.xml" rel="self"/>
  
  <link href="http://ryziii.github.io/"/>
  <updated>2020-12-04T08:40:38.739Z</updated>
  <id>http://ryziii.github.io/</id>
  
  <author>
    <name>Rysi</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>interview Redis</title>
    <link href="http://ryziii.github.io/post/912e298.html"/>
    <id>http://ryziii.github.io/post/912e298.html</id>
    <published>2020-11-23T10:04:52.000Z</published>
    <updated>2020-12-04T08:40:38.739Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Redis介绍"><a href="#Redis介绍" class="headerlink" title="Redis介绍"></a>Redis介绍</h2><h3 id="为什么Redis这么快"><a href="#为什么Redis这么快" class="headerlink" title="为什么Redis这么快"></a>为什么Redis这么快</h3><ul><li>完全基于内存，绝大部分请求是内存操作，执行效率高</li><li>数据结构简单，对数据操作也简单</li><li>采用单线程，单线程也能处理高并发请求，想多核也可以启动多实例</li><li>采用多路I/O复用，非阻塞I/O</li></ul><h3 id="Redis提供的数据类型"><a href="#Redis提供的数据类型" class="headerlink" title="Redis提供的数据类型"></a>Redis提供的数据类型</h3><ul><li>String： 基本数据类型</li><li><p>Hash： String元素组成的字典，适合用于存储对象</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// </span><br><span class="line">hmset lilei age 11 name &apos;Lilei&apos;</span><br><span class="line">hset lilei age 12</span><br><span class="line">hget lilei age</span><br></pre></td></tr></table></figure></code></pre></li><li><p>List： 列表，按照String元素插入顺序排序</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lpush mylist aaa</span><br><span class="line">lpush mylist bbb</span><br><span class="line">lrange mylist 0 100</span><br></pre></td></tr></table></figure></code></pre></li><li><p>Set： String元素组成的无序集合，通过哈希表实现，不允许重复</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// set是无序的</span><br><span class="line">sadd myset 11</span><br><span class="line">sadd myset aa</span><br><span class="line">smembers myset</span><br></pre></td></tr></table></figure></code></pre></li><li><p>Sorted Set： 通过分数来为集合中的成员进行从小到大排序</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">            // zset比set多了一个权重参数</span><br><span class="line">            127.0.0.1:6379&gt; zadd myzset 3 abc</span><br><span class="line">            (integer) 1</span><br><span class="line">            127.0.0.1:6379&gt; zadd myzset 1 ab</span><br><span class="line">            (integer) 1</span><br><span class="line">            127.0.0.1:6379&gt; zadd myzset 2 andn</span><br><span class="line">            (integer) 1</span><br><span class="line">            127.0.0.1:6379&gt; zadd myzset 2 andn</span><br><span class="line">            (integer) 0</span><br><span class="line">            127.0.0.1:6379&gt; zadd myzset 2 andnn</span><br><span class="line">            (integer) 1</span><br><span class="line">            127.0.0.1:6379&gt; zrangebyscore myzset 0 10</span><br><span class="line">            1) &quot;ab&quot;</span><br><span class="line">            2) &quot;andn&quot;</span><br><span class="line">            3) &quot;andnn&quot;</span><br><span class="line">            4) &quot;abc&quot;</span><br><span class="line">        ``` </span><br><span class="line">        </span><br><span class="line">- 用于计数的HyperLogLog</span><br><span class="line">- 用于存储地理位置信息的Geo</span><br><span class="line"></span><br><span class="line">### 从Redis中找到某一固定前缀的Key</span><br><span class="line"></span><br><span class="line">- Keys *返回全部，可能会阻塞服务器</span><br><span class="line">- 使用SCAN cursor [MATCH pattern] [COUNT count]</span><br><span class="line">    1. 基于光标的迭代器，需要给予上一次的光标延续之前的迭代过程</span><br><span class="line">    2. 以0作为光标开始的一次新的迭代，知道命令返回光标0完成一次遍历</span><br><span class="line">    3. 不保证每次执行都反悔某个COUNT指令给定数量的元素，支持模糊查询</span><br><span class="line">    4. 一次返回的数量不可控，只能大概率符合count参数</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 通过Redis实现分布式锁</span><br><span class="line"></span><br><span class="line">### 分布式锁需要解决的问题</span><br><span class="line"></span><br><span class="line">- 互斥性：只能有一个客户端获取锁</span><br><span class="line">- 安全性：锁只能被持有该锁的客户端删除不能由其他客户端删除</span><br><span class="line">- 死锁：需要有机制避免持有此锁的客户端当机而发生的其他客户端也无法获取此锁的</span><br><span class="line">- 容错：服务器宕机后客户端依然能获取锁释放锁</span><br><span class="line"></span><br><span class="line">### SETNX key value</span><br><span class="line"></span><br><span class="line">SETNX命令：</span><br><span class="line">- SETNX是原子操作</span><br><span class="line">- 时间复杂度为O(1)</span><br><span class="line">- 返回值：设置成功返回1，设置失败返回0</span><br></pre></td></tr></table></figure></code></pre><p>  127.0.0.1:6379&gt; get locknx<br>  (nil)<br>  127.0.0.1:6379&gt; setnx locknx test<br>  (integer) 1<br>  127.0.0.1:6379&gt; setnx locknx taks<br>  (integer) 0<br>  127.0.0.1:6379&gt; get locknx<br>  “test”</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">因为SETNX具有如上特点所以经常被用作分布式锁，但SETNX设置后长期有效，所以可以使用EXPIRE指令</span><br><span class="line"></span><br><span class="line">### EXPIRE key seconds </span><br><span class="line"></span><br><span class="line">EXPIRE指令用于设置key的生存时间，当key过期时(生存时间为0)，将会被自动删除</span><br><span class="line"></span><br><span class="line">### SETNX与EXPIRE原子性</span><br><span class="line"></span><br><span class="line">SETNX与EXPIRE指令操作都满足原子性，但被用作分布式锁操作时将两个操作合并在一起就不符合原子性了。使用SET key value [EX seconds] [PX milliseconds] [NX|XX]即可解决。 </span><br><span class="line"></span><br><span class="line">### SET key value [EX seconds] [PX milliseconds] [NX|XX]</span><br><span class="line"></span><br><span class="line">- EX seconds: 设置键的过期时间是秒</span><br><span class="line">- PX milliseconds: 设置键的过期时间是毫秒</span><br><span class="line">- NX: 如果键不存在则设置延迟</span><br><span class="line">- XX: 如果键存在才设置延迟</span><br><span class="line">- SET操作成功返回OK，否则返回nil</span><br></pre></td></tr></table></figure><p>  127.0.0.1:6379&gt; set locktarget 123 ex 10 nx<br>  OK<br>  127.0.0.1:6379&gt; get locktarget<br>  “123”<br>  127.0.0.1:6379&gt; set locktarget 123 ex 10 nx<br>  (nil)<br>  <code>`</code></p></li></ul><h3 id="怎么避免大量key同时过期"><a href="#怎么避免大量key同时过期" class="headerlink" title="怎么避免大量key同时过期"></a>怎么避免大量key同时过期</h3><p>redis大量key删除key需要耗费资源，大量key同时过期可能造成卡顿，此时新的请求就会向后端数据库获取数据，对数据库造成很大压力。</p><p>解决办法：</p><ol><li>设置key过期时间时，给key加上随机值</li><li>做二级缓存，A1为原始缓存，A2为二级缓存，A1失效时可以访问A2，A1过期时间为短期，A2位长期</li><li>在缓存失效后，通过加锁或队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据库和写缓存，其他线程等待。</li></ol><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p>一般的缓存系统都是从通过key查找value，如果找不到value则从数据库查找。某些恶意请求会故意查询许多不存在缓存中的key以此来攻击后端数据库系统。对后端压力很大，这就叫缓存穿透。</p><p>解决办法：</p><ol><li>对查询结果为空的key也进行缓存，设置缓存时间短一点。</li><li>对一些一定不存在的key做过滤，存在一个大的bitmap中，查询时对bitmap进行过滤。</li></ol><h2 id="如何使用Redis实现异步队列"><a href="#如何使用Redis实现异步队列" class="headerlink" title="如何使用Redis实现异步队列"></a>如何使用Redis实现异步队列</h2><h3 id="使用List"><a href="#使用List" class="headerlink" title="使用List"></a>使用List</h3><p>使用List作为队列，RPUSH生产消息，LPOP消费消息</p><p>缺点: 如果队列中的值都被消费完，那将出现没有等待队列中有值就消费的情况<br>解决上述缺点: </p><ol><li>可以在应用层引入Sleep机制去调用LPOP重试</li><li>不想使用Sleep机制，可以使用BLPOP key [key …] timeout (阻塞直到队列有消息或超时)，但因其阻塞的特性使其只能提供一个消费者消费</li><li>使用pub/sub订阅者模式解决上述问题，但该模式的发布是无状态的，无法保证可达，如果客户端下线再重新上线则无法收到之前的消息。</li><li>解决上述问题可以使用专业的消息队列中间件，如Kafka等</li></ol><h2 id="Redis-RDB持久化"><a href="#Redis-RDB持久化" class="headerlink" title="Redis RDB持久化"></a>Redis RDB持久化</h2><h3 id="Redis-RDB持久化方法"><a href="#Redis-RDB持久化方法" class="headerlink" title="Redis RDB持久化方法"></a>Redis RDB持久化方法</h3><p>RDB(Redis DataBase)快照持久化：保存某个时间点的全部数据快照。<br>此功能由redis.conf中的指令控制，在conf中常用到的指令有： </p><ul><li>SAVE: 阻塞redis服务器进程，直到RDB文件被创建完成</li><li>BGSAVE: Fork出一个子进程来创建RDB文件，不阻塞服务器进程</li></ul><h4 id="BGSAVE原理"><a href="#BGSAVE原理" class="headerlink" title="BGSAVE原理"></a>BGSAVE原理</h4><p><img src="https://i.imgur.com/tGWjEg1.png" alt="tGWjEg1"><br>当系统调用fork()时，创建进程实现Copy-on-Write</p><h5 id="什么是Copy-on-Write"><a href="#什么是Copy-on-Write" class="headerlink" title="什么是Copy-on-Write"></a>什么是Copy-on-Write</h5><p>当有多个调用者请求调用相同资源(在内存或者磁盘上的数据储存)，他们会获取相同的指向该资源的指针，直到某个调用者试图修改资源的内容时，系统才会真正的复制一份副本给该调用者，而其他调用者所见的最初的资源仍保持不变。</p><h3 id="自动化触发RDB持久化的方式"><a href="#自动化触发RDB持久化的方式" class="headerlink" title="自动化触发RDB持久化的方式"></a>自动化触发RDB持久化的方式</h3><ol><li>根据redis.conf配置里的SAVE m n定时触发(用的是BGSAVE)</li><li>主从复制时，主节点自动触发</li><li>执行Debug Reload</li><li>执行Shutdown且没有开启AOF持久化</li></ol><p>RDB持久化参考文章 <a href="https://juejin.cn/post/6844903886189395982" target="_blank" rel="noopener">https://juejin.cn/post/6844903886189395982</a></p><h3 id="RDB持久化的缺点"><a href="#RDB持久化的缺点" class="headerlink" title="RDB持久化的缺点"></a>RDB持久化的缺点</h3><ol><li>内存数据的全量同步，数据量大会由于I/O而严重影响性能</li><li>当redis突然挂掉的话，会丢失上次快照到当前时间的数据</li></ol><h2 id="Redis-AOF持久化"><a href="#Redis-AOF持久化" class="headerlink" title="Redis AOF持久化"></a>Redis AOF持久化</h2><h3 id="Reis-AOF是如何做持久化的"><a href="#Reis-AOF是如何做持久化的" class="headerlink" title="Reis AOF是如何做持久化的"></a>Reis AOF是如何做持久化的</h3><p>AOF(Append-Only-File)持久化: 保存写状态</p><ul><li>记录下除了了查询之外的左右变成数据库状态的指令</li><li>以append的形式追加到AOF文件中(增量)</li></ul><h3 id="日志重写结局AOF文件大小不断增大的问题"><a href="#日志重写结局AOF文件大小不断增大的问题" class="headerlink" title="日志重写结局AOF文件大小不断增大的问题"></a>日志重写结局AOF文件大小不断增大的问题</h3><ul><li>因为Reids会不断地往AOF文件中新增执行的命令记录，所以AOF文件在不断增大。极端情况下有可能占满磁盘可用空间</li><li>Redis重启后需要重新执行AOF文件中的命令以此来还原数据集，所以如果AOF文件越大则开启Redis后所需的等待时间就越长。</li></ul><p>为解决此问题，用户可以向Redis发送BGREWRITEAOF命令，这个命令会通过移除AOF文件的冗余来使AOF文件尽可能小。BGREWRITEAOF的原理同RDB持久化BGSAVE相同也需要用到Copy-On-Write特性，BGREWRITEAOF命令原理如下: </p><ol><li>调用fork()，创建一个子进程</li><li>子进程把新的AOF文件写进一个临时文件中，不依赖原来的AOF文件</li><li>主进程持续将新的变动同时写进内存和原来的AOF里</li><li>主进程获取子进程重写AOF的完成信号，往新的AOF同步增量变动</li><li>使用新的AOF文件替换掉旧的AOF文件</li></ol><h3 id="Reids持久化RDB与AOF对比"><a href="#Reids持久化RDB与AOF对比" class="headerlink" title="Reids持久化RDB与AOF对比"></a>Reids持久化RDB与AOF对比</h3><p>RDB优缺点: 本质上是内存备份，RDB的优点在于全量备份文件小恢复快，缺点在于无法保存创建RDB文件之后的增量数据<br>AOF优缺点: 本质上是一份执行日志，优点在于可读性高，适合保存增量数据，数据不易丢失，缺点在于文件体积大，做日志回放恢复时间较长</p><h3 id="RDB-AOF混合持久化方式"><a href="#RDB-AOF混合持久化方式" class="headerlink" title="RDB-AOF混合持久化方式"></a>RDB-AOF混合持久化方式</h3><p>使用RDB做全量持久化，用AOF做增量持久化</p><h2 id="Redis同步机制"><a href="#Redis同步机制" class="headerlink" title="Redis同步机制"></a>Redis同步机制</h2><h3 id="Redis-Pipeline"><a href="#Redis-Pipeline" class="headerlink" title="Redis Pipeline"></a>Redis Pipeline</h3><p>Redis的get操作是阻塞的，使用Pipeline可以批量执行命令，节省多次IO往返的时间。</p><h3 id="流言协议Gossip"><a href="#流言协议Gossip" class="headerlink" title="流言协议Gossip"></a>流言协议Gossip</h3><p>流言协议指的是随机在系统中传播信息，并在一定时间内使得整个系统节点的信息保持一致。</p><ul><li>每个节点都能随即地与对方通信，最终所有节点的状态达成一致。</li><li>种子节点定期随机向其他节点发送节点列表以及需要传播的信息。</li><li>不保证信息一定会传递给所有节点，但是最终会趋于一致。</li></ul><h2 id="Redis集群"><a href="#Redis集群" class="headerlink" title="Redis集群"></a>Redis集群</h2><p>Redis集群参考<a href="https://juejin.cn/post/6850418113830846471" target="_blank" rel="noopener">此篇文章</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Redis介绍&quot;&gt;&lt;a href=&quot;#Redis介绍&quot; class=&quot;headerlink&quot; title=&quot;Redis介绍&quot;&gt;&lt;/a&gt;Redis介绍&lt;/h2&gt;&lt;h3 id=&quot;为什么Redis这么快&quot;&gt;&lt;a href=&quot;#为什么Redis这么快&quot; class=&quot;he</summary>
      
    
    
    
    
    <category term="interview" scheme="http://ryziii.github.io/tags/interview/"/>
    
  </entry>
  
  <entry>
    <title>interview 数据库相关</title>
    <link href="http://ryziii.github.io/post/df0d4913.html"/>
    <id>http://ryziii.github.io/post/df0d4913.html</id>
    <published>2020-10-27T05:41:36.000Z</published>
    <updated>2020-12-03T11:21:54.967Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关系型数据库基本架构"><a href="#关系型数据库基本架构" class="headerlink" title="关系型数据库基本架构"></a>关系型数据库基本架构</h2><p><img src="https://i.imgur.com/Uq2eYn9.jpg" alt=""></p><h3 id="关系数据库索引所采取的数据结构"><a href="#关系数据库索引所采取的数据结构" class="headerlink" title="关系数据库索引所采取的数据结构"></a>关系数据库索引所采取的数据结构</h3><h4 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B Tree"></a>B Tree</h4><p><img src="https://i.imgur.com/0jVQ0S3.jpg" alt=""></p><h4 id="B-Tree-1"><a href="#B-Tree-1" class="headerlink" title="B+ Tree"></a>B+ Tree</h4><p><img src="https://i.imgur.com/jqDubwu.jpg" alt=""></p><h4 id="密集索引和稀疏索引"><a href="#密集索引和稀疏索引" class="headerlink" title="密集索引和稀疏索引"></a>密集索引和稀疏索引</h4><p>密集索引：文件中每个搜索码值都对应一个索引值<br>稀疏索引：文件只为索引码的某些值建立索引项 </p><h5 id="为什么要使用索引"><a href="#为什么要使用索引" class="headerlink" title="为什么要使用索引"></a>为什么要使用索引</h5><p>使用索引可以避免全表扫描，可以提升效率</p><h5 id="什么样的信息能成为索引"><a href="#什么样的信息能成为索引" class="headerlink" title="什么样的信息能成为索引"></a>什么样的信息能成为索引</h5><p>唯一键、主键、能将信息区分开的字段</p><h5 id="索引的数据结构"><a href="#索引的数据结构" class="headerlink" title="索引的数据结构"></a>索引的数据结构</h5><p>主流是B+Tree，还有哈希、bitmap等，MySql不支持bitmap，Inodb和MyISAM不支持哈希</p><h3 id="如何定位并优化慢查询Sql"><a href="#如何定位并优化慢查询Sql" class="headerlink" title="如何定位并优化慢查询Sql"></a>如何定位并优化慢查询Sql</h3><ol><li>根据慢查询日志定位慢查询sql</li><li>使用explain等工具分析sql</li><li>修改sql或者尽量让sql走索引</li></ol><h3 id="联合索引的最左匹配原则"><a href="#联合索引的最左匹配原则" class="headerlink" title="联合索引的最左匹配原则"></a>联合索引的最左匹配原则</h3><h4 id="什么是最左匹配原则"><a href="#什么是最左匹配原则" class="headerlink" title="什么是最左匹配原则"></a>什么是最左匹配原则</h4><p>mysql会一直向右匹配直到遇到范围查询（&gt;、&lt;、between、like）就停止匹配，比如a = 3 and b = 5 and c &gt; 5 and d = 6 如果建立(a,b,c,d)顺序的索引，d是用不到索引的</p><h4 id="联合索引的最左匹配原则成因"><a href="#联合索引的最左匹配原则成因" class="headerlink" title="联合索引的最左匹配原则成因"></a>联合索引的最左匹配原则成因</h4><p>最左前缀匹配成因：mysql 是创建复合索引的规则是根据索引最左边的字段进行排序，在第一个字段排序的基础上再进行第二个字段排序，类似于order by col1，col2… 所以第一个字段是绝对有序的 第二个字段就是无序的了，所以mysql 强调最左前缀匹配</p><h2 id="锁模块"><a href="#锁模块" class="headerlink" title="锁模块"></a>锁模块</h2><h3 id="写锁和读锁"><a href="#写锁和读锁" class="headerlink" title="写锁和读锁"></a>写锁和读锁</h3><p>读锁是共享锁，读锁上时不影响其他select读语句<br>写锁是排他锁，写锁上时其他写入语句别block住</p><blockquote><p>innodb默认支持行级锁</p></blockquote><h2 id="数据库事务的四大特性"><a href="#数据库事务的四大特性" class="headerlink" title="数据库事务的四大特性"></a>数据库事务的四大特性</h2><p>ACID</p><ul><li>原子性（Atomic）</li><li>一致性（Consistency）</li><li>隔离性（Isolation）</li><li>持久性（Durability）</li></ul><h2 id="Mysql复杂语句"><a href="#Mysql复杂语句" class="headerlink" title="Mysql复杂语句"></a>Mysql复杂语句</h2><p>GROUP BY</p><ul><li>满足’SELECT子句中的列名必须为分组列或列函数’</li><li>列函数对group by定义的每个组各返回一个结果 </li></ul><p>HAVING</p><ul><li>having通常与group by一起使用</li><li>where是用来过滤行，having用来过滤组</li><li>同一个sql语句中出现的顺序是：WHERE &gt; GROUP BY &gt; HAVING</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;关系型数据库基本架构&quot;&gt;&lt;a href=&quot;#关系型数据库基本架构&quot; class=&quot;headerlink&quot; title=&quot;关系型数据库基本架构&quot;&gt;&lt;/a&gt;关系型数据库基本架构&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/Uq2eYn9.</summary>
      
    
    
    
    
    <category term="interview" scheme="http://ryziii.github.io/tags/interview/"/>
    
  </entry>
  
  <entry>
    <title>interview HTTP协议相关</title>
    <link href="http://ryziii.github.io/post/28a3ef0.html"/>
    <id>http://ryziii.github.io/post/28a3ef0.html</id>
    <published>2020-10-22T12:30:49.000Z</published>
    <updated>2020-12-03T11:21:59.551Z</updated>
    
    <content type="html"><![CDATA[<h3 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h3><h4 id="HTTP协议特点"><a href="#HTTP协议特点" class="headerlink" title="HTTP协议特点"></a>HTTP协议特点</h4><ul><li>支持客户/服务器模式：浏览器向服务器请求</li><li>简单快速：get、post…</li><li>灵活：允许传输任意类型数据</li><li>无连接：请求结束后断开连接</li><li>无状态：不保留状态，之后的事务不知道之前的事</li></ul><h4 id="HTTP协议请求-响应步骤"><a href="#HTTP协议请求-响应步骤" class="headerlink" title="HTTP协议请求/响应步骤"></a>HTTP协议请求/响应步骤</h4><ol><li>客户端连接到Web服务器</li><li>客户端发送HTTP请求</li><li>服务器接受请求并返回HTTP响应</li><li>关闭TCP连接</li><li>客户端解析HTML</li></ol><h4 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h4><ol><li>1XX：提示信息</li><li>2XX：成功</li><li>3XX：重定向</li><li>4XX：客户端错误</li><li>5XX：服务端错误 </li></ol><h3 id="Cookie与Session"><a href="#Cookie与Session" class="headerlink" title="Cookie与Session"></a>Cookie与Session</h3><h4 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h4><p>服务器发给客户的信息，客户端以文本的形式保存在本地<br>Cookie的设置过程：<br><img src="https://i.imgur.com/2A4VivD.jpg" alt=""></p><h4 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h4><p>保存在服务器上<br>Session实现方式：<br><img src="https://i.imgur.com/SVAxPO9.jpg" alt=""></p><ol><li>使用Cookie实现：在Cookie中写入SessionID，这样在服务端和客户端交互时就带有SessionID</li><li>使用URL回写：服务器发给客户端页面中所有连接都带有SessionID，这样在浏览器点击任何一个URL时都会带回SessionID</li></ol><h4 id="Cookie与Session的区别"><a href="#Cookie与Session的区别" class="headerlink" title="Cookie与Session的区别"></a>Cookie与Session的区别</h4><ul><li>Cookie存储在客户端浏览器上，Session存储在服务器上</li><li>Session比Cookie安全（因为Cookie存放在本地，可以被人本地分析）</li><li>Session因为存放在服务器上所以会影响服务器性能，为减轻服务器开销应当使用Cookie</li></ul><h3 id="GET和POST请求的区别"><a href="#GET和POST请求的区别" class="headerlink" title="GET和POST请求的区别"></a>GET和POST请求的区别</h3><ul><li>HTTP报文层面：GET将请求信息放入URL，POST将请求信息放入报文体(bodyw)内（GET请求信息长度理论上不受限制，但实际上受浏览器客户端的限制）</li><li>数据库层面：GET符合幂等性和安全性，POST不符合（因为GET是做查询，不影响数据库）</li><li>其他层面：GET可以被缓存、被存储，POST不行</li></ul><h3 id="HTTP和HTTPS"><a href="#HTTP和HTTPS" class="headerlink" title="HTTP和HTTPS"></a>HTTP和HTTPS</h3><p>HTTPS为更安全的HTTP，比HTTP多了SSL</p><h4 id="SSL是什么"><a href="#SSL是什么" class="headerlink" title="SSL是什么"></a>SSL是什么</h4><p><img src="https://i.imgur.com/2d8R8ou.jpg" alt=""></p><h4 id="几类常见的加密方式"><a href="#几类常见的加密方式" class="headerlink" title="几类常见的加密方式"></a>几类常见的加密方式</h4><ul><li>对称加密：加解密使用同一个密钥</li><li>非对称加密：加解密使用的密钥都不用</li><li>哈希算法：将任意长度信息转换为固定长度的值，算法不可逆</li><li>数字签名：将签名加密附在信息中</li></ul><h4 id="HTTPS传输流程"><a href="#HTTPS传输流程" class="headerlink" title="HTTPS传输流程"></a>HTTPS传输流程</h4><ol><li>客户端将支持的加密算法信息发送给服务器</li><li>服务器选择一套客户端支持的加密算法，以证书的方式回发客户端</li><li>客户端验证证书的合法性，并结合证书公钥加密信息发送给服务器</li><li>服务器使用私钥揭秘信息，验证哈希，加密响应消息回发给客户端</li><li>客户端解密响应消息，并对消息进行验真，之后进行加密交互数据</li></ol><h4 id="HTTPS和HTTP区别"><a href="#HTTPS和HTTP区别" class="headerlink" title="HTTPS和HTTP区别"></a>HTTPS和HTTP区别</h4><ul><li>HTTPS需要到CA申请证书</li><li>HTTPS是密文传输，HTTP是明文传输（因为HTTPS经过SSL加密）</li><li>HTTPS使用的是443端口，HTTP使用80</li><li>HTTPS=HTTP+加密+认证+完整性保护</li></ul><h4 id="HTTPS真的安全吗"><a href="#HTTPS真的安全吗" class="headerlink" title="HTTPS真的安全吗"></a>HTTPS真的安全吗</h4><p>在浏览器上输入url时如果不输入https，则浏览器默认填充http，一般网站使用http跳转https，这时就容易受到攻击，应该使用HSTS标准优化</p><h5 id="HSTS"><a href="#HSTS" class="headerlink" title="HSTS"></a>HSTS</h5><p>HSTS（HTTP Strict Transport Security）是严格传输安全的缩写。<br>如果一个网站生命HSTS策略，则浏览器必须拒绝所有HTTP连接并阻止用户接受不安全的SSL证书。</p><h3 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h3><h4 id="Socket通信过程"><a href="#Socket通信过程" class="headerlink" title="Socket通信过程"></a>Socket通信过程</h4><p><img src="https://i.imgur.com/vFPDreT.jpg" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;HTTP协议&quot;&gt;&lt;a href=&quot;#HTTP协议&quot; class=&quot;headerlink&quot; title=&quot;HTTP协议&quot;&gt;&lt;/a&gt;HTTP协议&lt;/h3&gt;&lt;h4 id=&quot;HTTP协议特点&quot;&gt;&lt;a href=&quot;#HTTP协议特点&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    
    <category term="interview" scheme="http://ryziii.github.io/tags/interview/"/>
    
  </entry>
  
  <entry>
    <title>interview UDP相关</title>
    <link href="http://ryziii.github.io/post/27e25b32.html"/>
    <id>http://ryziii.github.io/post/27e25b32.html</id>
    <published>2020-10-22T12:17:25.000Z</published>
    <updated>2020-12-03T11:22:02.863Z</updated>
    
    <content type="html"><![CDATA[<h2 id="UDP协议的特点"><a href="#UDP协议的特点" class="headerlink" title="UDP协议的特点"></a>UDP协议的特点</h2><ul><li>UDP面向非连接</li><li>UDP不维护连接状态，支持同事向多个客户端传输相同的消息</li><li>数据包头只有8个字节，额外开销较小</li><li>吞吐量只受限于数据生成速率、传输速率以及机器性能</li><li>UDP不保证可靠交付</li><li>不对应用程序提交豹纹信息进行拆分或合并</li></ul><h3 id="由上结论得出TCP和UDP"><a href="#由上结论得出TCP和UDP" class="headerlink" title="由上结论得出TCP和UDP"></a>由上结论得出TCP和UDP</h3><ul><li>面向连接vs无连接：UDP常用于广播，多播发布，而TCP是面向连接的</li><li>可靠性：UDP无可靠性保证，TCP有握手重出传机制</li><li>有序性：TCP通过序号保证传输数据的有序性，UDP无序</li><li>速度：UDP速度更快，适合视频，游戏</li><li>量级：TCP20字节 UDP8字节</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;UDP协议的特点&quot;&gt;&lt;a href=&quot;#UDP协议的特点&quot; class=&quot;headerlink&quot; title=&quot;UDP协议的特点&quot;&gt;&lt;/a&gt;UDP协议的特点&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;UDP面向非连接&lt;/li&gt;
&lt;li&gt;UDP不维护连接状态，支持同事向多个客户端传</summary>
      
    
    
    
    
    <category term="interview" scheme="http://ryziii.github.io/tags/interview/"/>
    
  </entry>
  
  <entry>
    <title>interview TCP滑动窗口</title>
    <link href="http://ryziii.github.io/post/75d57196.html"/>
    <id>http://ryziii.github.io/post/75d57196.html</id>
    <published>2019-10-10T14:21:01.000Z</published>
    <updated>2020-12-03T11:21:16.250Z</updated>
    
    <content type="html"><![CDATA[<h2 id="RTT和RTO"><a href="#RTT和RTO" class="headerlink" title="RTT和RTO"></a>RTT和RTO</h2><ol><li>RTT是发送一个数据包到收到ACK所花费的时间；</li><li>RTO是重传时间间隔，当没有收到回应是，一定时间间隔后会重传数据包，RTO是根据RTT计算出的。</li></ol><h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><p><img src="https://i.imgur.com/xiCrFsF.png" alt=""><br><img src="https://i.imgur.com/sLuPbHQ.png" alt=""><br><img src="https://i.imgur.com/H52iLrk.png" alt=""><br>滑动窗口用于做流量控制和乱序重排<br>TCP发送方和接收方都维护着一个数据缓存区，<br>发送方缓存区有如下四种状态：</p><ol><li>已发送已收到ACK</li><li>已发送未收到ACK</li><li>未发送可发送</li><li>不可发送</li></ol><p>接收方缓存区有如下三种状态：</p><ol><li>已接收并已回复ACK</li><li>允许接收</li><li>不允许接收</li></ol><p><a href="https://www.cnblogs.com/lingyejun/p/7158028.html" target="_blank" rel="noopener">可参考1</a><br><a href="https://my.oschina.net/funcy/blog/3006133" target="_blank" rel="noopener">可参考2</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;RTT和RTO&quot;&gt;&lt;a href=&quot;#RTT和RTO&quot; class=&quot;headerlink&quot; title=&quot;RTT和RTO&quot;&gt;&lt;/a&gt;RTT和RTO&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;RTT是发送一个数据包到收到ACK所花费的时间；&lt;/li&gt;
&lt;li&gt;RTO是重传时间间隔</summary>
      
    
    
    
    
    <category term="interview" scheme="http://ryziii.github.io/tags/interview/"/>
    
  </entry>
  
  <entry>
    <title>interview TCP四次挥手</title>
    <link href="http://ryziii.github.io/post/beaf26b1.html"/>
    <id>http://ryziii.github.io/post/beaf26b1.html</id>
    <published>2019-10-10T13:12:24.000Z</published>
    <updated>2020-12-03T11:20:52.954Z</updated>
    
    <content type="html"><![CDATA[<h2 id="TCP四次挥手"><a href="#TCP四次挥手" class="headerlink" title="TCP四次挥手"></a>TCP四次挥手</h2><p><img src="https://ryziii.github.io/post-images/1570713886846.jpeg" alt="">[interview] TCP断开连接需要进行“四次挥手”</p><ol><li>Client向Server发送带有FIN包(seq = u)的包，用于关闭Client到Server的数据连接，并进入FIN_WAIT_1状态；</li><li>Server接收到FIN包后向Client发送一个ACK包(ack=u+1,seq=v),并进入CLOSE_WAIT状态,Client收到后进入FIN_WAIT_2;</li><li>待Server发送完数据后，再向Client发送一个FIN+ACK包(seq=w,ack=u+1)，用于关闭Server到Client的数据传送，并进入LAST_ACK状态；</li><li>Client收到FIN报文后进入TIMEWAIT状态，接着向Server发送一个ACK包(ack=w+1,seq=u+1)，Server进入CLOSE状态。</li></ol><blockquote><p>注：Client进入TIMEWAIT状态后2MSL后就进入CLOSE状态，Linux中MSL一般为30s。MSL是为了让Server有足够的时间收到最后一个ACK包。</p></blockquote><h2 id="为什么需要四次挥手"><a href="#为什么需要四次挥手" class="headerlink" title="为什么需要四次挥手"></a>为什么需要四次挥手</h2><p>因为TCP连接是全双工的，所以Client和Server都需要FIN报文和ACK报文。</p><h2 id="服务器出现大量CLISE-WAIT"><a href="#服务器出现大量CLISE-WAIT" class="headerlink" title="服务器出现大量CLISE_WAIT"></a>服务器出现大量CLISE_WAIT</h2><p>因为代码中没有释放资源<br>netstat -n |awk ‘/^tcp/{++S[$NF]}END{for(a in S) print a,S[a]}’</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;TCP四次挥手&quot;&gt;&lt;a href=&quot;#TCP四次挥手&quot; class=&quot;headerlink&quot; title=&quot;TCP四次挥手&quot;&gt;&lt;/a&gt;TCP四次挥手&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://ryziii.github.io/post-images/157</summary>
      
    
    
    
    
    <category term="interview" scheme="http://ryziii.github.io/tags/interview/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://ryziii.github.io/post/0.html"/>
    <id>http://ryziii.github.io/post/0.html</id>
    <published>2019-10-10T13:05:04.000Z</published>
    <updated>2020-12-03T11:20:46.116Z</updated>
    
    <content type="html"><![CDATA[<hr><p>title: interview 三次握手<br>abbrlink: 61361c3a<br>date: 2019-10-10 21:00:00<br>tags:</p><ul><li>interview</li></ul><hr><h2 id="三次握手过程"><a href="#三次握手过程" class="headerlink" title="三次握手过程"></a>三次握手过程</h2><p>在TCP/IP协议中，TCP通过三次握手来创建一个可靠的连接。</p><ol><li>第一次握手，发送端向服务器发送SYN包(syn=j)，并进入SYN_SEND状态，等待服务器回应。</li><li>第二次握手，服务器收到发送端发来的SYN包，必须确认发送端的SYN包(ack=j+1)，并发送一个SYN(syn=k),即SYN+ACK包。此时服务器进入SYN_RECIV状态。</li><li>第三次握手，客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1)，此时双方建立连接，进入ESTABLISHED状态，完成三次握手。</li></ol><h2 id="为什么需要三次握手？"><a href="#为什么需要三次握手？" class="headerlink" title="为什么需要三次握手？"></a>为什么需要三次握手？</h2><p>为了初始化Sequence Number，防止后续建立连接后发送数据乱序</p><h2 id="SYN超时隐患"><a href="#SYN超时隐患" class="headerlink" title="SYN超时隐患"></a>SYN超时隐患</h2><p>Server收到Client的SYN，发送SYN-ACK后未收到CLient的ACK确认，Server会不断重试直至超时，Linux默认63s<br>SYN超时会造成Server在时间内才会断开连接，攻击者会让服务器无法处理正常连接请求。Linux会构造一个SYNcookie只有请求者可以回复，防止被恶意进攻</p>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;p&gt;title: interview 三次握手&lt;br&gt;abbrlink: 61361c3a&lt;br&gt;date: 2019-10-10 21:00:00&lt;br&gt;tags:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;interview&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&quot;三次握</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>leetcode 104 递归</title>
    <link href="http://ryziii.github.io/post/bfd03033.html"/>
    <id>http://ryziii.github.io/post/bfd03033.html</id>
    <published>2019-01-25T08:31:30.000Z</published>
    <updated>2020-12-03T11:19:52.157Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接:<a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/</a></p><p>找树有几层,递归即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root==<span class="keyword">null</span>?<span class="number">0</span>:dfs(root,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode root,<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root.left==<span class="keyword">null</span>&amp;&amp;root.right==<span class="keyword">null</span>) <span class="keyword">return</span> len;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(root.left!=<span class="keyword">null</span>&amp;&amp;root.right==<span class="keyword">null</span>) <span class="keyword">return</span> dfs(root.left,len+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(root.left==<span class="keyword">null</span>&amp;&amp;root.right!=<span class="keyword">null</span>) <span class="keyword">return</span> dfs(root.right,len+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> Math.max(dfs(root.left,len+<span class="number">1</span>),dfs(root.right,len+<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//看到讨论区有个人一行搞定</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root == <span class="keyword">null</span> ? <span class="number">0</span> : Math.max(maxDepth(root.left), maxDepth(root.right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;题目链接:&lt;a href=&quot;https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/prob</summary>
      
    
    
    
    
    <category term="leetcode" scheme="http://ryziii.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 107 bfs</title>
    <link href="http://ryziii.github.io/post/d299569f.html"/>
    <id>http://ryziii.github.io/post/d299569f.html</id>
    <published>2019-01-25T08:27:26.000Z</published>
    <updated>2020-12-03T11:19:52.146Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接:<a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/</a></p><p>从下到上返回每层二叉树的值<br>用bfs</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrderBottom(TreeNode root) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; lists = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        LinkedList&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            queue.add(root);</span><br><span class="line">            List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            res.add(root.val);</span><br><span class="line">            lists.add(res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">int</span> n = queue.size();<span class="comment">//因为是每层的值,所以这里加一个循环</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">                TreeNode a = queue.removeFirst();</span><br><span class="line">                <span class="keyword">if</span> (a.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    res.add(a.left.val);</span><br><span class="line">                    queue.add(a.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (a.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    res.add(a.right.val);</span><br><span class="line">                    queue.add(a.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!res.isEmpty()) lists.add(res);</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.reverse(lists);</span><br><span class="line">        <span class="keyword">return</span> lists;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;题目链接:&lt;a href=&quot;https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.</summary>
      
    
    
    
    
    <category term="leetcode" scheme="http://ryziii.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 394 栈</title>
    <link href="http://ryziii.github.io/post/745a84ae.html"/>
    <id>http://ryziii.github.io/post/745a84ae.html</id>
    <published>2019-01-24T07:07:07.000Z</published>
    <updated>2020-12-03T11:22:18.542Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接:<a href="https://leetcode-cn.com/problems/decode-string/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/decode-string/</a></p><p>这题做了很久,用的递归的思路去解的,发现很痛苦,调试到最后都不知道自己的思路是什么了,懵懵的,过了以后看别人怎么写的,发现优雅的解法应该是用栈模拟</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> String <span class="title">decodeString</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> flag=<span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> c = s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">                <span class="keyword">if</span>(c&gt;=<span class="string">'0'</span>&amp;&amp;c&lt;=<span class="string">'9'</span>)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (c == <span class="string">'['</span>) &#123;</span><br><span class="line">                    num++;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">']'</span>) &#123;</span><br><span class="line">                    num--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (num == <span class="number">0</span>) &#123;</span><br><span class="line">                    flag = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(c&gt;=<span class="string">'0'</span>&amp;&amp;c&lt;=<span class="string">'9'</span>)&#123;</span><br><span class="line">                res.append(pinjie(s.substring(i)));</span><br><span class="line">                flag=<span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(c&gt;=<span class="string">'a'</span>&amp;&amp;c&lt;=<span class="string">'z'</span>)&#123;</span><br><span class="line">                res.append(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> StringBuilder <span class="title">pinjie</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        StringBuilder ss = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">boolean</span> flag=<span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>(c&gt;=<span class="string">'0'</span>&amp;&amp;c&lt;=<span class="string">'9'</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">                    ss.append(pinjie(s.substring(i)));</span><br><span class="line">                    <span class="keyword">boolean</span> fl = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">int</span> n=<span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;s.length();j++)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(s.charAt(j)==<span class="string">'['</span>&amp;&amp;!fl)&#123;</span><br><span class="line">                            n++;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span>(s.charAt(j)==<span class="string">']'</span>)&#123;</span><br><span class="line">                            n--;fl=<span class="keyword">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (n == <span class="number">0</span>&amp;&amp;fl) &#123;</span><br><span class="line">                            i=j;<span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    num = num*<span class="number">10</span>+(c-<span class="string">'0'</span>);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(!flag)&#123;</span><br><span class="line">                    flag=<span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(c==<span class="string">']'</span>)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;num;j++)&#123;</span><br><span class="line">                    res.append(ss);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(c==<span class="string">'['</span>) <span class="keyword">continue</span>;</span><br><span class="line">            ss.append(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//优雅版</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">decodeString</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        LinkedList&lt;String&gt; strlist = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        LinkedList&lt;Integer&gt; countlist = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">char</span>[] chars = s.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        StringBuilder sb  = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">while</span>(i&lt;chars.length)&#123;</span><br><span class="line">            <span class="keyword">while</span>(Character.isDigit(chars[i]))&#123;</span><br><span class="line">                sb.append(chars[i++]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!sb.toString().isEmpty())&#123;</span><br><span class="line">                countlist.addLast(Integer.valueOf(sb.toString()));</span><br><span class="line">                sb.delete(<span class="number">0</span>,sb.length());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(i&lt;chars.length&amp;&amp;Character.isLetter(chars[i]))&#123;</span><br><span class="line">                sb.append(chars[i++]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!sb.toString().isEmpty())&#123;</span><br><span class="line">                strlist.addLast(sb.toString());</span><br><span class="line">                sb.delete(<span class="number">0</span>,sb.length());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i&lt;chars.length&amp;&amp;chars[i]==<span class="string">'['</span>)&#123;</span><br><span class="line">                strlist.addLast(<span class="string">"["</span>);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            String str=<span class="string">""</span>;</span><br><span class="line">            <span class="keyword">if</span>(i&lt;chars.length&amp;&amp;chars[i]==<span class="string">']'</span>)&#123;</span><br><span class="line">                <span class="keyword">while</span>(!strlist.isEmpty()) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(!<span class="string">"["</span>.equals(strlist.peekLast()))&#123;</span><br><span class="line">                        str = strlist.pollLast()+str;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        strlist.pollLast();</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> count = countlist.removeLast();</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;count;j++)&#123;</span><br><span class="line">                    sb.append(str);</span><br><span class="line">                &#125;</span><br><span class="line">                strlist.addLast(sb.toString());</span><br><span class="line">                sb.delete(<span class="number">0</span>,sb.length());</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (String s1 : strlist) &#123;</span><br><span class="line">            sb.append(s1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;题目链接:&lt;a href=&quot;https://leetcode-cn.com/problems/decode-string/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/decode-str</summary>
      
    
    
    
    
    <category term="leetcode" scheme="http://ryziii.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 21 合并链表</title>
    <link href="http://ryziii.github.io/post/ce6d2c02.html"/>
    <id>http://ryziii.github.io/post/ce6d2c02.html</id>
    <published>2019-01-22T10:36:50.000Z</published>
    <updated>2020-10-21T08:21:20.825Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接:<a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/merge-two-sorted-lists/</a></p><p>想了很久逻辑拐不过弯来,发现数据结构还是要去看一下,最后没写错</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        ListNode li = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode res = li;</span><br><span class="line">        <span class="keyword">if</span>(l1==<span class="keyword">null</span>||l2==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> l1==<span class="keyword">null</span>?l2:l1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(l1!=<span class="keyword">null</span>||l2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l1==<span class="keyword">null</span>)&#123;</span><br><span class="line">                res.next = l2;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">                res = res.next;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(l2==<span class="keyword">null</span>)&#123;</span><br><span class="line">                res.next = l1;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">                res = res.next;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(l1.val&gt;=l2.val)&#123;</span><br><span class="line">                res.next = l2;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">                res = res.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                res.next = l1;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">                res = res.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> li.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//我在发现两个链表不同长时还是一个一个填充,写完后看了眼讨论区,发现两个链表不同长时可以在最后直接填到res.next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        ListNode li = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode res = li;</span><br><span class="line">        <span class="keyword">if</span>(l1==<span class="keyword">null</span>||l2==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> l1==<span class="keyword">null</span>?l2:l1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(l1!=<span class="keyword">null</span>||l2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l1.val&gt;=l2.val)&#123;</span><br><span class="line">                res.next = l2;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">                res = res.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                res.next = l1;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">                res = res.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l1==<span class="keyword">null</span>)&#123;</span><br><span class="line">            res.next = l2;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            res.next = l1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> li.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;题目链接:&lt;a href=&quot;https://leetcode-cn.com/problems/merge-two-sorted-lists/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/m</summary>
      
    
    
    
    
    <category term="leetcode" scheme="http://ryziii.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 88</title>
    <link href="http://ryziii.github.io/post/1c0f5e68.html"/>
    <id>http://ryziii.github.io/post/1c0f5e68.html</id>
    <published>2019-01-22T09:45:15.000Z</published>
    <updated>2020-12-03T11:22:18.547Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接<a href="https://leetcode-cn.com/problems/merge-sorted-array/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/merge-sorted-array/</a></p><p>拼装数组,有序的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span> m, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[m+n];</span><br><span class="line">        <span class="keyword">int</span> len=<span class="number">0</span>,l1=<span class="number">0</span>,l2=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(l1&lt;m||l2&lt;n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l1&gt;=m)&#123;</span><br><span class="line">                res[len++]=nums2[l2++];</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(l2&gt;=n)&#123;</span><br><span class="line">                res[len++]=nums1[l1++];</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(nums1[l1]==nums2[l2])&#123;</span><br><span class="line">                res[len++]=nums1[l1++];</span><br><span class="line">                res[len++]=nums2[l2++];</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(nums1[l1]&gt;nums2[l2])&#123;</span><br><span class="line">                res[len++]=nums2[l2++];</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(nums1[l1]&lt;nums2[l2]) &#123;</span><br><span class="line">                res[len++] = nums1[l1++];</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;res.length;i++)&#123;</span><br><span class="line">            nums1[i]=res[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写完后看了下讨论区,有的人写的真挺漂亮</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span> m, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p = m-- + n-- - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (m &gt;= <span class="number">0</span> &amp;&amp; n &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            nums1[p--] = nums1[m] &gt; nums2[n] ? nums1[m--] : nums2[n--];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (n &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            nums1[p--] = nums2[n--];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;题目链接&lt;a href=&quot;https://leetcode-cn.com/problems/merge-sorted-array/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/merge-</summary>
      
    
    
    
    
    <category term="leetcode" scheme="http://ryziii.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 26</title>
    <link href="http://ryziii.github.io/post/1589be5.html"/>
    <id>http://ryziii.github.io/post/1589be5.html</id>
    <published>2019-01-22T09:12:55.000Z</published>
    <updated>2020-10-21T08:21:20.807Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接:<a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/</a></p><p>直接把后面的塞前面就行了,题目说不考虑后面只返回len</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>,i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;nums.length)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]!=nums[len])&#123;</span><br><span class="line">                nums[len++]=nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;题目链接:&lt;a href=&quot;https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.c</summary>
      
    
    
    
    
    <category term="leetcode" scheme="http://ryziii.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>简单回溯 leetcode 100</title>
    <link href="http://ryziii.github.io/post/a6ac1cf.html"/>
    <id>http://ryziii.github.io/post/a6ac1cf.html</id>
    <published>2019-01-22T08:45:55.000Z</published>
    <updated>2020-10-21T08:21:20.740Z</updated>
    
    <content type="html"><![CDATA[<p>题目地址:<a href="https://leetcode-cn.com/problems/same-tree/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/same-tree/</a></p><p>这道题写了两种方法,第一种方法太蠢了,后来改进用了第二种,其实本质就是让写个equal,我第一种方法竟然选择遍历二叉树存进map里再用map的equal去判断,蠢哭了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//遍历后equal</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSameTree</span><span class="params">(TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        Map&lt;String,Object&gt; map1 = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        Map&lt;String,Object&gt; map2 = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        getTree(p,map1,<span class="number">1</span>);</span><br><span class="line">        getTree(q,map2,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> map1.equals(map2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getTree</span><span class="params">(TreeNode q,Map&lt;String,Object&gt; map,<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(q==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            map.put(<span class="string">"val"</span>+i,q.val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(q.left == <span class="keyword">null</span>)&#123;</span><br><span class="line">            map.put(<span class="string">"left"</span>+i,<span class="keyword">null</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            map.put(<span class="string">"left"</span>+i,q.left.val);</span><br><span class="line">            getTree(q.left,map,<span class="number">2</span>*i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(q.right==<span class="keyword">null</span>)&#123;</span><br><span class="line">            map.put(<span class="string">"right"</span>+i,<span class="keyword">null</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            map.put(<span class="string">"right"</span>+i,q.right.val);</span><br><span class="line">            getTree(q.right,map,<span class="number">2</span>*i+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//直接回溯</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSameTree</span><span class="params">(TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        Map&lt;String,Object&gt; map1 = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        Map&lt;String,Object&gt; map2 = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">return</span> getTree(p,q);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">getTree</span><span class="params">(TreeNode q,TreeNode p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(q==<span class="keyword">null</span> &amp;&amp; p==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(q!=<span class="keyword">null</span>&amp;&amp;p!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">boolean</span> flag3 = q.val == p.val;</span><br><span class="line">            <span class="keyword">boolean</span> flag1 = getTree(q.left,p.left);</span><br><span class="line">            <span class="keyword">boolean</span> flag2 = getTree(q.right,p.right);</span><br><span class="line">            <span class="keyword">if</span>(flag1&amp;&amp; flag2&amp;&amp;flag3)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//直接回溯方法2</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSameTree</span><span class="params">(TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (q == <span class="keyword">null</span> &amp;&amp; p == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (q == <span class="keyword">null</span> || p == <span class="keyword">null</span> || q.val != p.val) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isSameTree(q.left, p.left) &amp;&amp; isSameTree(q.right, p.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;题目地址:&lt;a href=&quot;https://leetcode-cn.com/problems/same-tree/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/same-tree/&lt;/a&gt;</summary>
      
    
    
    
    
    <category term="leetcode" scheme="http://ryziii.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>简单模拟题 leetcode-12</title>
    <link href="http://ryziii.github.io/post/83597930.html"/>
    <id>http://ryziii.github.io/post/83597930.html</id>
    <published>2019-01-22T07:49:28.000Z</published>
    <updated>2020-10-21T08:21:20.746Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接:<a href="https://leetcode-cn.com/problems/integer-to-roman/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/integer-to-roman/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">intToRoman</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        Map&lt;String,Integer&gt; map = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">"M"</span>,<span class="number">1000</span>);</span><br><span class="line">        map.put(<span class="string">"CM"</span>,<span class="number">900</span>);</span><br><span class="line">        map.put(<span class="string">"D"</span>,<span class="number">500</span>);</span><br><span class="line">        map.put(<span class="string">"CD"</span>,<span class="number">400</span>);</span><br><span class="line">        map.put(<span class="string">"C"</span>,<span class="number">100</span>);</span><br><span class="line">        map.put(<span class="string">"XC"</span>,<span class="number">90</span>);</span><br><span class="line">        map.put(<span class="string">"L"</span>,<span class="number">50</span>);</span><br><span class="line">        map.put(<span class="string">"XL"</span>,<span class="number">40</span>);</span><br><span class="line">        map.put(<span class="string">"X"</span>,<span class="number">10</span>);</span><br><span class="line">        map.put(<span class="string">"IX"</span>,<span class="number">9</span>);</span><br><span class="line">        map.put(<span class="string">"V"</span>,<span class="number">5</span>);</span><br><span class="line">        map.put(<span class="string">"IV"</span>,<span class="number">4</span>);</span><br><span class="line">        map.put(<span class="string">"I"</span>,<span class="number">1</span>);</span><br><span class="line">        StringBuilder sb  =<span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">while</span>(num!=<span class="number">0</span>)&#123;</span><br><span class="line">            Iterator it = map.keySet().iterator();</span><br><span class="line">            <span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">                String c = (String) it.next();</span><br><span class="line">                <span class="keyword">int</span> va = map.get(c);</span><br><span class="line">                <span class="keyword">if</span>(num&gt;=va)&#123;</span><br><span class="line">                    sb.append(c);</span><br><span class="line">                    num-=va;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;题目链接:&lt;a href=&quot;https://leetcode-cn.com/problems/integer-to-roman/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/integer</summary>
      
    
    
    
    
    <category term="leetcode" scheme="http://ryziii.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>简单模拟 leetcode-13</title>
    <link href="http://ryziii.github.io/post/3a681d24.html"/>
    <id>http://ryziii.github.io/post/3a681d24.html</id>
    <published>2019-01-22T07:15:53.000Z</published>
    <updated>2020-10-21T08:21:20.802Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接:<a href="https://leetcode-cn.com/problems/roman-to-integer/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/roman-to-integer/</a></p><p>遍历string,只要右边比当前值大就减去当前值<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">romanToInt</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Map&lt;Character,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">'I'</span>,<span class="number">1</span>);</span><br><span class="line">        map.put(<span class="string">'V'</span>,<span class="number">5</span>);</span><br><span class="line">        map.put(<span class="string">'X'</span>,<span class="number">10</span>);</span><br><span class="line">        map.put(<span class="string">'L'</span>,<span class="number">50</span>);</span><br><span class="line">        map.put(<span class="string">'C'</span>,<span class="number">100</span>);</span><br><span class="line">        map.put(<span class="string">'D'</span>,<span class="number">500</span>);</span><br><span class="line">        map.put(<span class="string">'M'</span>,<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">            Integer cur = map.get(s.charAt(i));</span><br><span class="line">            Integer nx;</span><br><span class="line">            <span class="keyword">if</span>(i+<span class="number">1</span>&gt;= s.length())&#123;</span><br><span class="line">                sum+=cur;</span><br><span class="line">                <span class="keyword">return</span> sum;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                nx = map.get(s.charAt(i+<span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cur&lt;nx)&#123;</span><br><span class="line">                sum-=cur;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                sum+=cur;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;题目链接:&lt;a href=&quot;https://leetcode-cn.com/problems/roman-to-integer/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/roman-t</summary>
      
    
    
    
    
    <category term="leetcode" scheme="http://ryziii.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>全排列简单版-回溯 leetcode.784</title>
    <link href="http://ryziii.github.io/post/9e8d94d3.html"/>
    <id>http://ryziii.github.io/post/9e8d94d3.html</id>
    <published>2019-01-22T04:08:26.000Z</published>
    <updated>2020-10-21T08:21:20.783Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接:<a href="https://leetcode-cn.com/problems/letter-case-permutation/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/letter-case-permutation/</a></p><p>题意就是给定字符串输出该字符串所有英文字母的大小写形式<br>回溯全排列即可 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//全排列</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">letterCasePermutation</span><span class="params">(String S)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        huisuo(list,<span class="number">0</span>,S.length(),<span class="keyword">new</span> StringBuilder(),S);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">huisuo</span><span class="params">(List&lt;String&gt; list,<span class="keyword">int</span> len,<span class="keyword">int</span> rellen,StringBuilder sb,String ss)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(len == rellen)&#123;</span><br><span class="line">            list.add(sb.toString());</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">char</span> c = ss.charAt(len);</span><br><span class="line">        <span class="keyword">if</span>((c &gt;= <span class="string">'a'</span> &amp;&amp; c &lt;= <span class="string">'z'</span>) || (c &gt;= <span class="string">'A'</span> &amp;&amp; c&lt;= <span class="string">'Z'</span>))&#123;</span><br><span class="line">            huisuo(list,len+<span class="number">1</span>,rellen,sb.append(Character.toUpperCase(c)),ss);</span><br><span class="line">            sb.deleteCharAt(sb.length()-<span class="number">1</span>);</span><br><span class="line">            huisuo(list,len+<span class="number">1</span>,rellen,sb.append(Character.toLowerCase(c)),ss);</span><br><span class="line">            sb.deleteCharAt(sb.length()-<span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            huisuo(list,len+<span class="number">1</span>,rellen,sb.append(c),ss);</span><br><span class="line">            sb.deleteCharAt(sb.length()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;题目链接:&lt;a href=&quot;https://leetcode-cn.com/problems/letter-case-permutation/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/</summary>
      
    
    
    
    
    <category term="leetcode" scheme="http://ryziii.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>html基础知识记录(持续更新)</title>
    <link href="http://ryziii.github.io/post/318304a3.html"/>
    <id>http://ryziii.github.io/post/318304a3.html</id>
    <published>2019-01-22T02:43:22.000Z</published>
    <updated>2020-10-21T08:21:20.793Z</updated>
    
    <content type="html"><![CDATA[<h3 id="u-标签"><a href="#u-标签" class="headerlink" title="u 标签"></a>u 标签</h3><p>u标签表斜体,如:<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">u</span>&gt;</span>111<span class="tag">&lt;/<span class="name">u</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p><u>111</u></p><h3 id="strong-标签"><a href="#strong-标签" class="headerlink" title="strong 标签"></a>strong 标签</h3><p>b标签为粗体,strong在浏览器上的效果看上去相同,但是strong标签有着重强调的意思,另附一个小知识,盲人朋友们在使用阅读设备时,strong标签会让文字重(zhong)读</p><h3 id="em标签"><a href="#em标签" class="headerlink" title="em标签"></a>em标签</h3><p>em 标签也表强调,在浏览器上效果为斜体</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;u-标签&quot;&gt;&lt;a href=&quot;#u-标签&quot; class=&quot;headerlink&quot; title=&quot;u 标签&quot;&gt;&lt;/a&gt;u 标签&lt;/h3&gt;&lt;p&gt;u标签表斜体,如:&lt;br&gt;&lt;figure class=&quot;highlight html&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td cla</summary>
      
    
    
    
    
    <category term="html" scheme="http://ryziii.github.io/tags/html/"/>
    
  </entry>
  
  <entry>
    <title>MySQL的limit与分页查询</title>
    <link href="http://ryziii.github.io/post/cf5eab58.html"/>
    <id>http://ryziii.github.io/post/cf5eab58.html</id>
    <published>2019-01-22T02:18:41.000Z</published>
    <updated>2020-10-21T08:21:20.763Z</updated>
    
    <content type="html"><![CDATA[<h2 id="limit用法"><a href="#limit用法" class="headerlink" title="limit用法"></a>limit用法</h2><p>在mysql中有时需要使用限制查找行数,这在mysql语句中有自带的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM tableName LIMIT [offset,] rows|LIMIT rows OFFSET length</span><br><span class="line"></span><br><span class="line">SELECT * FROM table WHERE username = 1 LIMIT 10 OFFSET 5</span><br><span class="line">SELECT * FROM table WHERE username = 1 LIMIT 5,10</span><br></pre></td></tr></table></figure></p><p>LIMIT可以用于返回指定数量的mysql记录,LIMIT接受一个或两个整形参数.如果给了两个参数,第一个参数为<strong><u>偏移量</u></strong>,第二个参数为指定返回记录数.<strong><u>mysql初始记录数行偏移量为0不是1</u></strong></p><p>如果需要检索某一偏移量到记录集结束的所有记录集,可以指定第二个参数为-1<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM table LIMIT 5,-1</span><br></pre></td></tr></table></figure></p><h2 id="mysql分页查询性能分析"><a href="#mysql分页查询性能分析" class="headerlink" title="mysql分页查询性能分析"></a>mysql分页查询性能分析</h2><p>基本的mysql分页方式就是<code>SELECT ... FORM ... WHERE ... ORDER BY ... LIMIT ...</code><br>当数据量增大,子页变多,<u>LIMIT语句的偏移量增大时,查询速度会变慢</u><br>有几种方法可以提高查询速度</p><ol><li>通过自查询的方式优化速度</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM table WHERE id &gt;= </span><br><span class="line">(SELECT id FROM table WHERE username = &apos;11&apos; ORDER BY id LIMIT 10000,1) LIMIT 10</span><br></pre></td></tr></table></figure><ol><li>通过join分页方式</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM &apos;table1&apos; AS t1</span><br><span class="line">JOIN (SELECT id FROM &apos;table1&apos; ORDER BY id ASC LIMIT &quot;.($page-1)*$pagesize.&quot;,1) AS t2</span><br><span class="line">WHERE t1.id &lt;= t2.id ORDER BY t1.id ASC LIMIT $pagesize;</span><br></pre></td></tr></table></figure><p>参考链接:<a href="https://segmentfault.com/a/1190000008859706" target="_blank" rel="noopener">https://segmentfault.com/a/1190000008859706</a></p><h2 id="分析结果"><a href="#分析结果" class="headerlink" title="分析结果"></a>分析结果</h2><p>不使用分页查询直接用limit查询的话大数据量如100w的话mysql性能收到很大影响,<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SQL代码1：平均用时6.6秒 SELECT * FROM `cdb_posts` ORDER BY pid LIMIT 1000000 , 30</span><br><span class="line"></span><br><span class="line">SQL代码2：平均用时0.6秒 SELECT * FROM `cdb_posts` WHERE pid &gt;= (SELECT pid FROM  </span><br><span class="line">`cdb_posts` ORDER BY pid LIMIT 1000000 , 1) LIMIT 30</span><br></pre></td></tr></table></figure></p><p>因为要取出所有字段内容，第一种需要跨越大量数据块并取出，而第二种基本通过直接根据索引字段定位后，才取出相应内容，效率自然大大提升。对limit的优化，不是直接使用limit，而是首先获取到offset的id，然后直接使用limit size来获取数据。<br><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fzf767ld4fj31640mewi6.jpg" alt=""><br><strong>为了保证index索引列连续，可以为每个表加一个自增字段，并且加上索引</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;limit用法&quot;&gt;&lt;a href=&quot;#limit用法&quot; class=&quot;headerlink&quot; title=&quot;limit用法&quot;&gt;&lt;/a&gt;limit用法&lt;/h2&gt;&lt;p&gt;在mysql中有时需要使用限制查找行数,这在mysql语句中有自带的&lt;br&gt;&lt;figure clas</summary>
      
    
    
    
    
    <category term="Mysql" scheme="http://ryziii.github.io/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>HttpServletRequest——获取URL方法</title>
    <link href="http://ryziii.github.io/post/19bd0d6c.html"/>
    <id>http://ryziii.github.io/post/19bd0d6c.html</id>
    <published>2019-01-22T02:06:26.000Z</published>
    <updated>2020-10-21T08:21:20.776Z</updated>
    
    <content type="html"><![CDATA[<h3 id="request-getRequestURL"><a href="#request-getRequestURL" class="headerlink" title="request.getRequestURL()"></a>request.getRequestURL()</h3><p>返回的是完整的url，包括Http协议，端口号，servlet名字和映射路径，但它不包含请求参数。</p><h3 id="request-getRequestURI"><a href="#request-getRequestURI" class="headerlink" title="request.getRequestURI()"></a>request.getRequestURI()</h3><pre><code>得到的是request URL的部分值，并且web容器没有decode过的</code></pre><h3 id="request-getContextPath"><a href="#request-getContextPath" class="headerlink" title="request.getContextPath()"></a>request.getContextPath()</h3><pre><code>返回 the context of the request.</code></pre><h3 id="request-getServletPath"><a href="#request-getServletPath" class="headerlink" title="request.getServletPath()"></a>request.getServletPath()</h3><pre><code>返回调用servlet的部分url.</code></pre><h3 id="request-getQueryString"><a href="#request-getQueryString" class="headerlink" title="request.getQueryString()"></a>request.getQueryString()</h3><pre><code>返回url路径后面的查询字符串</code></pre><h3 id="获得客户机信息"><a href="#获得客户机信息" class="headerlink" title="获得客户机信息"></a>获得客户机信息</h3><pre><code>getRequestURL方法返回客户端发出请求时的完整URL。getRequestURI方法返回请求行中的资源名部分。getQueryString 方法返回请求行中的参数部分。getRemoteAddr方法返回发出请求的客户机的IP地址 getRemoteHost方法返回发出请求的客户机的完整主机名getRemotePort方法返回客户机所使用的网络端口号getLocalAddr方法返回WEB服务器的IP地址。getLocalName方法返回WEB服务器的主机名 getMethod得到客户机请求方式</code></pre><h3 id="获得客户机请求头"><a href="#获得客户机请求头" class="headerlink" title="获得客户机请求头"></a>获得客户机请求头</h3><pre><code>getHeader(string name)方法 getHeaders(String name)方法 getHeaderNames方法 </code></pre><h3 id="获得客户机请求参数-客户端提交的数据"><a href="#获得客户机请求参数-客户端提交的数据" class="headerlink" title="获得客户机请求参数(客户端提交的数据)"></a>获得客户机请求参数(客户端提交的数据)</h3><pre><code>getParameter(name)方法getParameterValues（String name）方法getParameterNames方法 getParameterMap方法</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;request-getRequestURL&quot;&gt;&lt;a href=&quot;#request-getRequestURL&quot; class=&quot;headerlink&quot; title=&quot;request.getRequestURL()&quot;&gt;&lt;/a&gt;request.getRequestURL</summary>
      
    
    
    
    
    <category term="Java" scheme="http://ryziii.github.io/tags/Java/"/>
    
    <category term="HttpServletRequest" scheme="http://ryziii.github.io/tags/HttpServletRequest/"/>
    
  </entry>
  
</feed>
